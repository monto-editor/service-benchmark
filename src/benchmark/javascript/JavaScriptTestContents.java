package benchmark.javascript;

import java.util.ArrayList;
import java.util.Arrays;

import monto.service.message.Languages;
import monto.service.message.LongKey;
import monto.service.message.Selection;
import monto.service.message.Source;
import monto.service.message.VersionMessage;

public class JavaScriptTestContents {
	public static final String LINES10 = "/** taken from https://github.com/ladieslearningcode/JavaScript/blob/master/src/prettify.js */  \nfunction appendDecorations(basePos, sourceCode, langHandler, out) {\n    if (!sourceCode) { return; }\n    var job = {\n      source: sourceCode,\n      basePos: basePos\n    };\n    langHandler(job);\n    out.push.apply(out, job.decorations);\n  }\n";
	public static final String LINES100 = "/** taken from https://github.com/ladieslearningcode/JavaScript/blob/master/src/prettify.js */  \n\nwindow['PR_SHOULD_USE_CONTINUATION'] = true;\n\nwindow['PR_TAB_WIDTH'] = 8;\n\nwindow['PR']\n\n  = window['prettyPrintOne']\n  = window['prettyPrint'] = void 0;\n\n\n(function () {\n  // Keyword lists for various languages.\n  var FLOW_CONTROL_KEYWORDS =\n      \"break continue do else for if return while \";\n  var C_KEYWORDS = FLOW_CONTROL_KEYWORDS + \"auto case char const default \" +\n      \"double enum extern float goto int long register short signed sizeof \" +\n      \"static struct switch typedef union unsigned void volatile \";\n  var COMMON_KEYWORDS = C_KEYWORDS + \"catch class delete false import \" +\n      \"new operator private protected public this throw true try typeof \";\n  var CPP_KEYWORDS = COMMON_KEYWORDS + \"alignof align_union asm axiom bool \" +\n      \"concept concept_map const_cast constexpr decltype \" +\n      \"dynamic_cast explicit export friend inline late_check \" +\n      \"mutable namespace nullptr reinterpret_cast static_assert static_cast \" +\n      \"template typeid typename using virtual wchar_t where \";\n  var JAVA_KEYWORDS = COMMON_KEYWORDS +\n      \"abstract boolean byte extends final finally implements import \" +\n      \"instanceof null native package strictfp super synchronized throws \" +\n      \"transient \";\n  var CSHARP_KEYWORDS = JAVA_KEYWORDS +\n      \"as base by checked decimal delegate descending dynamic event \" +\n      \"fixed foreach from group implicit in interface internal into is lock \" +\n      \"object out override orderby params partial readonly ref sbyte sealed \" +\n      \"stackalloc string select uint ulong unchecked unsafe ushort var \";\n  var COFFEE_KEYWORDS = \"all and by catch class else extends false finally \" +\n      \"for if in is isnt loop new no not null of off on or return super then \" +\n      \"true try unless until when while yes \";\n  var JSCRIPT_KEYWORDS = COMMON_KEYWORDS +\n      \"debugger eval export function get null set undefined var with \" +\n      \"Infinity NaN \";\n  var PERL_KEYWORDS = \"caller delete die do dump elsif eval exit foreach for \" +\n      \"goto if import last local my next no our print package redo require \" +\n      \"sub undef unless until use wantarray while BEGIN END \";\n  var PYTHON_KEYWORDS = FLOW_CONTROL_KEYWORDS + \"and as assert class def del \" +\n      \"elif except exec finally from global import in is lambda \" +\n      \"nonlocal not or pass print raise try with yield \" +\n      \"False True None \";\n  var RUBY_KEYWORDS = FLOW_CONTROL_KEYWORDS + \"alias and begin case class def\" +\n      \" defined elsif end ensure false in module next nil not or redo rescue \" +\n      \"retry self super then true undef unless until when yield BEGIN END \";\n  var SH_KEYWORDS = FLOW_CONTROL_KEYWORDS + \"case done elif esac eval fi \" +\n      \"function in local set then until \";\n  var ALL_KEYWORDS = (\n      CPP_KEYWORDS + CSHARP_KEYWORDS + JSCRIPT_KEYWORDS + PERL_KEYWORDS +\n      PYTHON_KEYWORDS + RUBY_KEYWORDS + SH_KEYWORDS);\n\n  // token style names.  correspond to css classes\n  var PR_STRING = 'str';\n  var PR_KEYWORD = 'kwd';\n  var PR_COMMENT = 'com';\n  var PR_TYPE = 'typ';\n  var PR_LITERAL = 'lit';\n  var PR_PUNCTUATION = 'pun';\n  var PR_PLAIN = 'pln';\n\n  /** token style for an sgml tag. */\n  var PR_TAG = 'tag';\n  var PR_DECLARATION = 'dec';\n  var PR_SOURCE = 'src';\n  var PR_ATTRIB_NAME = 'atn';\n  var PR_ATTRIB_VALUE = 'atv';\n  PR\n\n  /**\n   * A class that indicates a section of markup that is not code, e.g. to allow\n   * embedding of line numbers within code listings.\n   */\n  var PR_NOCODE = 'nocode';\n\n  var REGEXP_PRECEDER_PATTERN = function () {\n      var preceders = [\n          \"!\", \"!=\", \"!==\", \"#\", \"%\", \"%=\", \"&\", \"&&\", \"&&=\",\n          \"&=\", \"(\", \"*\", \"*=\", /* \"+\", */ \"+=\", \",\", /* \"-\", */ \"-=\",\n          \"->\", /*\".\", \"..\", \"...\", handled below */ \"/\", \"/=\", \":\", \"::\", \";\",\n          \"<\", \"<<\", \"<<=\", \"<=\", \"=\", \"==\", \"===\", \">\",\n          \">=\", \">>\", \">>=\", \">>>\", \">>>=\", \"?\", \"@\", \"[\",\n          \"^\", \"^=\", \"^^\", \"^^=\", \"{\", \"|\", \"|=\", \"||\",\n          \"||=\", \"~\" /* handles =~ and !~ */,\n          \"break\", \"case\", \"continue\", \"delete\",\n          \"do\", \"else\", \"finally\", \"instanceof\",\n          \"return\", \"throw\", \"try\", \"typeof\"\n          ];\n      var pattern = '(?:^^|[+-]';\n      for (var i = 0; i < preceders.length; ++i) {\n        pattern += '|' + preceders[i].replace(/([^=<>:&a-z])/g, '\\\\$1');\n      }\n      pattern += ')\\\\s*';  // matches at end, and matches empty string\n      return pattern;\n\n    }();\n";
	public static final String LINES1000 = "/** taken from https://github.com/ladieslearningcode/JavaScript/blob/master/src/prettify.js */  \n// Copyright (C) 2006 Google Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\n/**\n * @fileoverview\n * some functions for browser-side pretty printing of code contained in html.\n *\n * <p>\n * For a fairly comprehensive set of languages see the\n * <a href=\"http://google-code-prettify.googlecode.com/svn/trunk/README.html#langs\">README</a>\n * file that came with this source.  At a minimum, the lexer should work on a\n * number of languages including C and friends, Java, Python, Bash, SQL, HTML,\n * XML, CSS, Javascript, and Makefiles.  It works passably on Ruby, PHP and Awk\n * and a subset of Perl, but, because of commenting conventions, doesn't work on\n * Smalltalk, Lisp-like, or CAML-like languages without an explicit lang class.\n * <p>\n * Usage: <ol>\n * <li> include this source file in an html page via\n *   {@code <script type=\"text/javascript\" src=\"/path/to/prettify.js\"></script>}\n * <li> define style rules.  See the example page for examples.\n * <li> mark the {@code <pre>} and {@code <code>} tags in your source with\n *    {@code class=prettyprint.}\n *    You can also use the (html deprecated) {@code <xmp>} tag, but the pretty\n *    printer needs to do more substantial DOM manipulations to support that, so\n *    some css styles may not be preserved.\n * </ol>\n * That's it.  I wanted to keep the API as simple as possible, so there's no\n * need to specify which language the code is in, but if you wish, you can add\n * another class to the {@code <pre>} or {@code <code>} element to specify the\n * language, as in {@code <pre class=\"prettyprint lang-java\">}.  Any class that\n * starts with \"lang-\" followed by a file extension, specifies the file type.\n * See the \"lang-*.js\" files in this directory for code that implements\n * per-language file handlers.\n * <p>\n * Change log:<br>\n * cbeust, 2006/08/22\n * <blockquote>\n *   Java annotations (start with \"@\") are now captured as literals (\"lit\")\n * </blockquote>\n * @requires console\n */\n\n// JSLint declarations\n/*global console, document, navigator, setTimeout, window */\n\n/**\n * Split {@code prettyPrint} into multiple timeouts so as not to interfere with\n * UI events.\n * If set to {@code false}, {@code prettyPrint()} is synchronous.\n */\nwindow['PR_SHOULD_USE_CONTINUATION'] = true;\n\n/** the number of characters between tab columns */\nwindow['PR_TAB_WIDTH'] = 8;\n\n/** Contains functions for creating and registering new language handlers.\n  * @type {Object}\n  */\nwindow['PR']\n\n/** Pretty print a chunk of code.\n  *\n  * @param {string} sourceCodeHtml code as html\n  * @return {string} code as html, but prettier\n  */\n  = window['prettyPrintOne']\n/** Find all the {@code <pre>} and {@code <code>} tags in the DOM with\n  * {@code class=prettyprint} and prettify them.\n  * @param {Function?} opt_whenDone if specified, called when the last entry\n  *     has been finished.\n  */\n  = window['prettyPrint'] = void 0;\n\n\n(function () {\n  // Keyword lists for various languages.\n  var FLOW_CONTROL_KEYWORDS =\n      \"break continue do else for if return while \";\n  var C_KEYWORDS = FLOW_CONTROL_KEYWORDS + \"auto case char const default \" +\n      \"double enum extern float goto int long register short signed sizeof \" +\n      \"static struct switch typedef union unsigned void volatile \";\n  var COMMON_KEYWORDS = C_KEYWORDS + \"catch class delete false import \" +\n      \"new operator private protected public this throw true try typeof \";\n  var CPP_KEYWORDS = COMMON_KEYWORDS + \"alignof align_union asm axiom bool \" +\n      \"concept concept_map const_cast constexpr decltype \" +\n      \"dynamic_cast explicit export friend inline late_check \" +\n      \"mutable namespace nullptr reinterpret_cast static_assert static_cast \" +\n      \"template typeid typename using virtual wchar_t where \";\n  var JAVA_KEYWORDS = COMMON_KEYWORDS +\n      \"abstract boolean byte extends final finally implements import \" +\n      \"instanceof null native package strictfp super synchronized throws \" +\n      \"transient \";\n  var CSHARP_KEYWORDS = JAVA_KEYWORDS +\n      \"as base by checked decimal delegate descending dynamic event \" +\n      \"fixed foreach from group implicit in interface internal into is lock \" +\n      \"object out override orderby params partial readonly ref sbyte sealed \" +\n      \"stackalloc string select uint ulong unchecked unsafe ushort var \";\n  var COFFEE_KEYWORDS = \"all and by catch class else extends false finally \" +\n      \"for if in is isnt loop new no not null of off on or return super then \" +\n      \"true try unless until when while yes \";\n  var JSCRIPT_KEYWORDS = COMMON_KEYWORDS +\n      \"debugger eval export function get null set undefined var with \" +\n      \"Infinity NaN \";\n  var PERL_KEYWORDS = \"caller delete die do dump elsif eval exit foreach for \" +\n      \"goto if import last local my next no our print package redo require \" +\n      \"sub undef unless until use wantarray while BEGIN END \";\n  var PYTHON_KEYWORDS = FLOW_CONTROL_KEYWORDS + \"and as assert class def del \" +\n      \"elif except exec finally from global import in is lambda \" +\n      \"nonlocal not or pass print raise try with yield \" +\n      \"False True None \";\n  var RUBY_KEYWORDS = FLOW_CONTROL_KEYWORDS + \"alias and begin case class def\" +\n      \" defined elsif end ensure false in module next nil not or redo rescue \" +\n      \"retry self super then true undef unless until when yield BEGIN END \";\n  var SH_KEYWORDS = FLOW_CONTROL_KEYWORDS + \"case done elif esac eval fi \" +\n      \"function in local set then until \";\n  var ALL_KEYWORDS = (\n      CPP_KEYWORDS + CSHARP_KEYWORDS + JSCRIPT_KEYWORDS + PERL_KEYWORDS +\n      PYTHON_KEYWORDS + RUBY_KEYWORDS + SH_KEYWORDS);\n\n  // token style names.  correspond to css classes\n  /** token style for a string literal */\n  var PR_STRING = 'str';\n  /** token style for a keyword */\n  var PR_KEYWORD = 'kwd';\n  /** token style for a comment */\n  var PR_COMMENT = 'com';\n  /** token style for a type */\n  var PR_TYPE = 'typ';\n  /** token style for a literal value.  e.g. 1, null, true. */\n  var PR_LITERAL = 'lit';\n  /** token style for a punctuation string. */\n  var PR_PUNCTUATION = 'pun';\n  /** token style for a punctuation string. */\n  var PR_PLAIN = 'pln';\n\n  /** token style for an sgml tag. */\n  var PR_TAG = 'tag';\n  /** token style for a markup declaration such as a DOCTYPE. */\n  var PR_DECLARATION = 'dec';\n  /** token style for embedded source. */\n  var PR_SOURCE = 'src';\n  /** token style for an sgml attribute name. */\n  var PR_ATTRIB_NAME = 'atn';\n  /** token style for an sgml attribute value. */\n  var PR_ATTRIB_VALUE = 'atv';\nPR\n  /**\n   * A class that indicates a section of markup that is not code, e.g. to allow\n   * embedding of line numbers within code listings.\n   */\n  var PR_NOCODE = 'nocode';\n\n  /** A set of tokens that can precede a regular expression literal in\n    * javascript.\n    * http://www.mozilla.org/js/language/js20/rationale/syntax.html has the full\n    * list, but I've removed ones that might be problematic when seen in\n    * languages that don't support regular expression literals.\n    *\n    * <p>Specifically, I've removed any keywords that can't precede a regexp\n    * literal in a syntactically legal javascript program, and I've removed the\n    * \"in\" keyword since it's not a keyword in many languages, and might be used\n    * as a count of inches.\n    *\n    * <p>The link a above does not accurately describe EcmaScript rules since\n    * it fails to distinguish between (a=++/b/i) and (a++/b/i) but it works\n    * very well in practice.\n    *\n    * @private\n    */\n  var REGEXP_PRECEDER_PATTERN = function () {\n      var preceders = [\n          \"!\", \"!=\", \"!==\", \"#\", \"%\", \"%=\", \"&\", \"&&\", \"&&=\",\n          \"&=\", \"(\", \"*\", \"*=\", /* \"+\", */ \"+=\", \",\", /* \"-\", */ \"-=\",\n          \"->\", /*\".\", \"..\", \"...\", handled below */ \"/\", \"/=\", \":\", \"::\", \";\",\n          \"<\", \"<<\", \"<<=\", \"<=\", \"=\", \"==\", \"===\", \">\",\n          \">=\", \">>\", \">>=\", \">>>\", \">>>=\", \"?\", \"@\", \"[\",\n          \"^\", \"^=\", \"^^\", \"^^=\", \"{\", \"|\", \"|=\", \"||\",\n          \"||=\", \"~\" /* handles =~ and !~ */,\n          \"break\", \"case\", \"continue\", \"delete\",\n          \"do\", \"else\", \"finally\", \"instanceof\",\n          \"return\", \"throw\", \"try\", \"typeof\"\n          ];\n      var pattern = '(?:^^|[+-]';\n      for (var i = 0; i < preceders.length; ++i) {\n        pattern += '|' + preceders[i].replace(/([^=<>:&a-z])/g, '\\\\$1');\n      }\n      pattern += ')\\\\s*';  // matches at end, and matches empty string\n      return pattern;\n      // CAVEAT: this does not properly handle the case where a regular\n      // expression immediately follows another since a regular expression may\n      // have flags for case-sensitivity and the like.  Having regexp tokens\n      // adjacent is not valid in any language I'm aware of, so I'm punting.\n      // TODO: maybe style special characters inside a regexp as punctuation.\n    }();\n\n  \n  /**\n   * Given a group of {@link RegExp}s, returns a {@code RegExp} that globally\n   * matches the union of the sets of strings matched by the input RegExp.\n   * Since it matches globally, if the input strings have a start-of-input\n   * anchor (/^.../), it is ignored for the purposes of unioning.\n   * @param {Array.<RegExp>} regexs non multiline, non-global regexs.\n   * @return {RegExp} a global regex.\n   */\n  function combinePrefixPatterns(regexs) {\n    var capturedGroupIndex = 0;\n  \n    var needToFoldCase = false;\n    var ignoreCase = false;\n    for (var i = 0, n = regexs.length; i < n; ++i) {\n      var regex = regexs[i];\n      if (regex.ignoreCase) {\n        ignoreCase = true;\n      } else if (/[a-z]/i.test(regex.source.replace(\n                     /\\\\u[0-9a-f]{4}|\\\\x[0-9a-f]{2}|\\\\[^ux]/gi, ''))) {\n        needToFoldCase = true;\n        ignoreCase = false;\n        break;\n      }\n    }\n  \n    function decodeEscape(charsetPart) {\n      if (charsetPart.charAt(0) !== '\\\\') { return charsetPart.charCodeAt(0); }\n      switch (charsetPart.charAt(1)) {\n        case 'b': return 8;\n        case 't': return 9;\n        case 'n': return 0xa;\n        case 'v': return 0xb;\n        case 'f': return 0xc;\n        case 'r': return 0xd;\n        case 'u': case 'x':\n          return parseInt(charsetPart.substring(2), 16)\n              || charsetPart.charCodeAt(1);\n        case '0': case '1': case '2': case '3': case '4':\n        case '5': case '6': case '7':\n          return parseInt(charsetPart.substring(1), 8);\n        default: return charsetPart.charCodeAt(1);\n      }\n    }\n  \n    function encodeEscape(charCode) {\n      if (charCode < 0x20) {\n        return (charCode < 0x10 ? '\\\\x0' : '\\\\x') + charCode.toString(16);\n      }\n      var ch = String.fromCharCode(charCode);\n      if (ch === '\\\\' || ch === '-' || ch === '[' || ch === ']') {\n        ch = '\\\\' + ch;\n      }\n      return ch;\n    }\n  \n    function caseFoldCharset(charSet) {\n      var charsetParts = charSet.substring(1, charSet.length - 1).match(\n          new RegExp(\n              '\\\\\\\\u[0-9A-Fa-f]{4}'\n              + '|\\\\\\\\x[0-9A-Fa-f]{2}'\n              + '|\\\\\\\\[0-3][0-7]{0,2}'\n              + '|\\\\\\\\[0-7]{1,2}'\n              + '|\\\\\\\\[\\\\s\\\\S]'\n              + '|-'\n              + '|[^-\\\\\\\\]',\n              'g'));\n      var groups = [];\n      var ranges = [];\n      var inverse = charsetParts[0] === '^';\n      for (var i = inverse ? 1 : 0, n = charsetParts.length; i < n; ++i) {\n        var p = charsetParts[i];\n        switch (p) {\n          case '\\\\B': case '\\\\b':\n          case '\\\\D': case '\\\\d':\n          case '\\\\S': case '\\\\s':\n          case '\\\\W': case '\\\\w':\n            groups.push(p);\n            continue;\n        }\n        var start = decodeEscape(p);\n        var end;\n        if (i + 2 < n && '-' === charsetParts[i + 1]) {\n          end = decodeEscape(charsetParts[i + 2]);\n          i += 2;\n        } else {\n          end = start;\n        }\n        ranges.push([start, end]);\n        // If the range might intersect letters, then expand it.\n        if (!(end < 65 || start > 122)) {\n          if (!(end < 65 || start > 90)) {\n            ranges.push([Math.max(65, start) | 32, Math.min(end, 90) | 32]);\n          }\n          if (!(end < 97 || start > 122)) {\n            ranges.push([Math.max(97, start) & ~32, Math.min(end, 122) & ~32]);\n          }\n        }\n      }\n  \n      // [[1, 10], [3, 4], [8, 12], [14, 14], [16, 16], [17, 17]]\n      // -> [[1, 12], [14, 14], [16, 17]]\n      ranges.sort(function (a, b) { return (a[0] - b[0]) || (b[1]  - a[1]); });\n      var consolidatedRanges = [];\n      var lastRange = [NaN, NaN];\n      for (var i = 0; i < ranges.length; ++i) {\n        var range = ranges[i];\n        if (range[0] <= lastRange[1] + 1) {\n          lastRange[1] = Math.max(lastRange[1], range[1]);\n        } else {\n          consolidatedRanges.push(lastRange = range);\n        }\n      }\n  \n      var out = ['['];\n      if (inverse) { out.push('^'); }\n      out.push.apply(out, groups);\n      for (var i = 0; i < consolidatedRanges.length; ++i) {\n        var range = consolidatedRanges[i];\n        out.push(encodeEscape(range[0]));\n        if (range[1] > range[0]) {\n          if (range[1] + 1 > range[0]) { out.push('-'); }\n          out.push(encodeEscape(range[1]));\n        }\n      }\n      out.push(']');\n      return out.join('');\n    }\n  \n    function allowAnywhereFoldCaseAndRenumberGroups(regex) {\n      // Split into character sets, escape sequences, punctuation strings\n      // like ('(', '(?:', ')', '^'), and runs of characters that do not\n      // include any of the above.\n      var parts = regex.source.match(\n          new RegExp(\n              '(?:'\n              + '\\\\[(?:[^\\\\x5C\\\\x5D]|\\\\\\\\[\\\\s\\\\S])*\\\\]'  // a character set\n              + '|\\\\\\\\u[A-Fa-f0-9]{4}'  // a unicode escape\n              + '|\\\\\\\\x[A-Fa-f0-9]{2}'  // a hex escape\n              + '|\\\\\\\\[0-9]+'  // a back-reference or octal escape\n              + '|\\\\\\\\[^ux0-9]'  // other escape sequence\n              + '|\\\\(\\\\?[:!=]'  // start of a non-capturing group\n              + '|[\\\\(\\\\)\\\\^]'  // start/emd of a group, or line start\n              + '|[^\\\\x5B\\\\x5C\\\\(\\\\)\\\\^]+'  // run of other characters\n              + ')',\n              'g'));\n      var n = parts.length;\n  \n      // Maps captured group numbers to the number they will occupy in\n      // the output or to -1 if that has not been determined, or to\n      // undefined if they need not be capturing in the output.\n      var capturedGroups = [];\n  \n      // Walk over and identify back references to build the capturedGroups\n      // mapping.\n      for (var i = 0, groupIndex = 0; i < n; ++i) {\n        var p = parts[i];\n        if (p === '(') {\n          // groups are 1-indexed, so max group index is count of '('\n          ++groupIndex;\n        } else if ('\\\\' === p.charAt(0)) {\n          var decimalValue = +p.substring(1);\n          if (decimalValue && decimalValue <= groupIndex) {\n            capturedGroups[decimalValue] = -1;\n          }\n        }\n      }\n  \n      // Renumber groups and reduce capturing groups to non-capturing groups\n      // where possible.\n      for (var i = 1; i < capturedGroups.length; ++i) {\n        if (-1 === capturedGroups[i]) {\n          capturedGroups[i] = ++capturedGroupIndex;\n        }\n      }\n      for (var i = 0, groupIndex = 0; i < n; ++i) {\n        var p = parts[i];\n        if (p === '(') {\n          ++groupIndex;\n          if (capturedGroups[groupIndex] === undefined) {\n            parts[i] = '(?:';\n          }\n        } else if ('\\\\' === p.charAt(0)) {\n          var decimalValue = +p.substring(1);\n          if (decimalValue && decimalValue <= groupIndex) {\n            parts[i] = '\\\\' + capturedGroups[groupIndex];\n          }\n        }\n      }\n  \n      // Remove any prefix anchors so that the output will match anywhere.\n      // ^^ really does mean an anchored match though.\n      for (var i = 0, groupIndex = 0; i < n; ++i) {\n        if ('^' === parts[i] && '^' !== parts[i + 1]) { parts[i] = ''; }\n      }\n  \n      // Expand letters to groups to handle mixing of case-sensitive and\n      // case-insensitive patterns if necessary.\n      if (regex.ignoreCase && needToFoldCase) {\n        for (var i = 0; i < n; ++i) {\n          var p = parts[i];\n          var ch0 = p.charAt(0);\n          if (p.length >= 2 && ch0 === '[') {\n            parts[i] = caseFoldCharset(p);\n          } else if (ch0 !== '\\\\') {\n            // TODO: handle letters in numeric escapes.\n            parts[i] = p.replace(\n                /[a-zA-Z]/g,\n                function (ch) {\n                  var cc = ch.charCodeAt(0);\n                  return '[' + String.fromCharCode(cc & ~32, cc | 32) + ']';\n                });\n          }\n        }\n      }\n  \n      return parts.join('');\n    }\n  \n    var rewritten = [];\n    for (var i = 0, n = regexs.length; i < n; ++i) {\n      var regex = regexs[i];\n      if (regex.global || regex.multiline) { throw new Error('' + regex); }\n      rewritten.push(\n          '(?:' + allowAnywhereFoldCaseAndRenumberGroups(regex) + ')');\n    }\n  \n    return new RegExp(rewritten.join('|'), ignoreCase ? 'gi' : 'g');\n  }\n\n\n  /**\n   * Split markup into a string of source code and an array mapping ranges in\n   * that string to the text nodes in which they appear.\n   *\n   * <p>\n   * The HTML DOM structure:</p>\n   * <pre>\n   * (Element   \"p\"\n   *   (Element \"b\"\n   *     (Text  \"print \"))       ; #1\n   *   (Text    \"'Hello '\")      ; #2\n   *   (Element \"br\")            ; #3\n   *   (Text    \"  + 'World';\")) ; #4\n   * </pre>\n   * <p>\n   * corresponds to the HTML\n   * {@code <p><b>print </b>'Hello '<br>  + 'World';</p>}.</p>\n   *\n   * <p>\n   * It will produce the output:</p>\n   * <pre>\n   * {\n   *   source: \"print 'Hello '\\n  + 'World';\",\n   *   //                 1         2\n   *   //       012345678901234 5678901234567\n   *   spans: [0, #1, 6, #2, 14, #3, 15, #4]\n   * }\n   * </pre>\n   * <p>\n   * where #1 is a reference to the {@code \"print \"} text node above, and so\n   * on for the other text nodes.\n   * </p>\n   *\n   * <p>\n   * The {@code} spans array is an array of pairs.  Even elements are the start\n   * indices of substrings, and odd elements are the text nodes (or BR elements)\n   * that contain the text for those substrings.\n   * Substrings continue until the next index or the end of the source.\n   * </p>\n   *\n   * @param {Node} node an HTML DOM subtree containing source-code.\n   * @return {Object} source code and the text nodes in which they occur.\n   */\n  function extractSourceSpans(node) {\n    var nocode = /(?:^|\\s)nocode(?:\\s|$)/;\n  \n    var chunks = [];\n    var length = 0;\n    var spans = [];\n    var k = 0;\n  \n    var whitespace;\n    if (node.currentStyle) {\n      whitespace = node.currentStyle.whiteSpace;\n    } else if (window.getComputedStyle) {\n      whitespace = document.defaultView.getComputedStyle(node, null)\n          .getPropertyValue('white-space');\n    }\n    var isPreformatted = whitespace && 'pre' === whitespace.substring(0, 3);\n  \n    function walk(node) {\n      switch (node.nodeType) {\n        case 1:  // Element\n          if (nocode.test(node.className)) { return; }\n          for (var child = node.firstChild; child; child = child.nextSibling) {\n            walk(child);\n          }\n          var nodeName = node.nodeName;\n          if ('BR' === nodeName || 'LI' === nodeName) {\n            chunks[k] = '\\n';\n            spans[k << 1] = length++;\n            spans[(k++ << 1) | 1] = node;\n          }\n          break;\n        case 3: case 4:  // Text\n          var text = node.nodeValue;\n          if (text.length) {\n            if (!isPreformatted) {\n              text = text.replace(/[ \\t\\r\\n]+/g, ' ');\n            } else {\n              text = text.replace(/\\r\\n?/g, '\\n');  // Normalize newlines.\n            }\n            // TODO: handle tabs here?\n            chunks[k] = text;\n            spans[k << 1] = length;\n            length += text.length;\n            spans[(k++ << 1) | 1] = node;\n          }\n          break;\n      }\n    }\n  \n    walk(node);\n  \n    return {\n      source: chunks.join('').replace(/\\n$/, ''),\n      spans: spans\n    };\n  }\n\n\n  /**\n   * Apply the given language handler to sourceCode and add the resulting\n   * decorations to out.\n   * @param {number} basePos the index of sourceCode within the chunk of source\n   *    whose decorations are already present on out.\n   */\n  function appendDecorations(basePos, sourceCode, langHandler, out) {\n    if (!sourceCode) { return; }\n    var job = {\n      source: sourceCode,\n      basePos: basePos\n    };\n    langHandler(job);\n    out.push.apply(out, job.decorations);\n  }\n\n  /** Given triples of [style, pattern, context] returns a lexing function,\n    * The lexing function interprets the patterns to find token boundaries and\n    * returns a decoration list of the form\n    * [index_0, style_0, index_1, style_1, ..., index_n, style_n]\n    * where index_n is an index into the sourceCode, and style_n is a style\n    * constant like PR_PLAIN.  index_n-1 <= index_n, and style_n-1 applies to\n    * all characters in sourceCode[index_n-1:index_n].\n    *\n    * The stylePatterns is a list whose elements have the form\n    * [style : string, pattern : RegExp, DEPRECATED, shortcut : string].\n    *\n    * Style is a style constant like PR_PLAIN, or can be a string of the\n    * form 'lang-FOO', where FOO is a language extension describing the\n    * language of the portion of the token in $1 after pattern executes.\n    * E.g., if style is 'lang-lisp', and group 1 contains the text\n    * '(hello (world))', then that portion of the token will be passed to the\n    * registered lisp handler for formatting.\n    * The text before and after group 1 will be restyled using this decorator\n    * so decorators should take care that this doesn't result in infinite\n    * recursion.  For example, the HTML lexer rule for SCRIPT elements looks\n    * something like ['lang-js', /<[s]cript>(.+?)<\\/script>/].  This may match\n    * '<script>foo()<\\/script>', which would cause the current decorator to\n    * be called with '<script>' which would not match the same rule since\n    * group 1 must not be empty, so it would be instead styled as PR_TAG by\n    * the generic tag rule.  The handler registered for the 'js' extension would\n    * then be called with 'foo()', and finally, the current decorator would\n    * be called with '<\\/script>' which would not match the original rule and\n    * so the generic tag rule would identify it as a tag.\n    *\n    * Pattern must only match prefixes, and if it matches a prefix, then that\n    * match is considered a token with the same style.\n    *\n    * Context is applied to the last non-whitespace, non-comment token\n    * recognized.\n    *\n    * Shortcut is an optional string of characters, any of which, if the first\n    * character, gurantee that this pattern and only this pattern matches.\n    *\n    * @param {Array} shortcutStylePatterns patterns that always start with\n    *   a known character.  Must have a shortcut string.\n    * @param {Array} fallthroughStylePatterns patterns that will be tried in\n    *   order if the shortcut ones fail.  May have shortcuts.\n    *\n    * @return {function (Object)} a\n    *   function that takes source code and returns a list of decorations.\n    */\n  function createSimpleLexer(shortcutStylePatterns, fallthroughStylePatterns) {\n    var shortcuts = {};\n    var tokenizer;\n    (function () {\n      var allPatterns = shortcutStylePatterns.concat(fallthroughStylePatterns);\n      var allRegexs = [];\n      var regexKeys = {};\n      for (var i = 0, n = allPatterns.length; i < n; ++i) {\n        var patternParts = allPatterns[i];\n        var shortcutChars = patternParts[3];\n        if (shortcutChars) {\n          for (var c = shortcutChars.length; --c >= 0;) {\n            shortcuts[shortcutChars.charAt(c)] = patternParts;\n          }\n        }\n        var regex = patternParts[1];\n        var k = '' + regex;\n        if (!regexKeys.hasOwnProperty(k)) {\n          allRegexs.push(regex);\n          regexKeys[k] = null;\n        }\n      }\n      allRegexs.push(/[\\0-\\uffff]/);\n      tokenizer = combinePrefixPatterns(allRegexs);\n    })();\n\n    var nPatterns = fallthroughStylePatterns.length;\n    var notWs = /\\S/;\n\n    /**\n     * Lexes job.source and produces an output array job.decorations of style\n     * classes preceded by the position at which they start in job.source in\n     * order.\n     *\n     * @param {Object} job an object like {@code\n     *    source: {string} sourceText plain text,\n     *    basePos: {int} position of job.source in the larger chunk of\n     *        sourceCode.\n     * }\n     */\n    var decorate = function (job) {\n      var sourceCode = job.source, basePos = job.basePos;\n      /** Even entries are positions in source in ascending order.  Odd enties\n        * are style markers (e.g., PR_COMMENT) that run from that position until\n        * the end.\n        * @type {Array.<number|string>}\n        */\n      var decorations = [basePos, PR_PLAIN];\n      var pos = 0;  // index into sourceCode\n      var tokens = sourceCode.match(tokenizer) || [];\n      var styleCache = {};\n\n      for (var ti = 0, nTokens = tokens.length; ti < nTokens; ++ti) {\n        var token = tokens[ti];\n        var style = styleCache[token];\n        var match = void 0;\n\n        var isEmbedded;\n        if (typeof style === 'string') {\n          isEmbedded = false;\n        } else {\n          var patternParts = shortcuts[token.charAt(0)];\n          if (patternParts) {\n            match = token.match(patternParts[1]);\n            style = patternParts[0];\n          } else {\n            for (var i = 0; i < nPatterns; ++i) {\n              patternParts = fallthroughStylePatterns[i];\n              match = token.match(patternParts[1]);\n              if (match) {\n                style = patternParts[0];\n                break;\n              }\n            }\n\n            if (!match) {  // make sure that we make progress\n              style = PR_PLAIN;\n            }\n          }\n\n          isEmbedded = style.length >= 5 && 'lang-' === style.substring(0, 5);\n          if (isEmbedded && !(match && typeof match[1] === 'string')) {\n            isEmbedded = false;\n            style = PR_SOURCE;\n          }\n\n          if (!isEmbedded) { styleCache[token] = style; }\n        }\n\n        var tokenStart = pos;\n        pos += token.length;\n\n        if (!isEmbedded) {\n          decorations.push(basePos + tokenStart, style);\n        } else {  // Treat group 1 as an embedded block of source code.\n          var embeddedSource = match[1];\n          var embeddedSourceStart = token.indexOf(embeddedSource);\n          var embeddedSourceEnd = embeddedSourceStart + embeddedSource.length;\n          if (match[2]) {\n            // If embeddedSource can be blank, then it would match at the\n            // beginning which would cause us to infinitely recurse on the\n            // entire token, so we catch the right context in match[2].\n            embeddedSourceEnd = token.length - match[2].length;\n            embeddedSourceStart = embeddedSourceEnd - embeddedSource.length;\n          }\n          var lang = style.substring(5);\n          // Decorate the left of the embedded source\n          appendDecorations(\n              basePos + tokenStart,\n              token.substring(0, embeddedSourceStart),\n              decorate, decorations);\n          // Decorate the embedded source\n          appendDecorations(\n              basePos + tokenStart + embeddedSourceStart,\n              embeddedSource,\n              langHandlerForExtension(lang, embeddedSource),\n              decorations);\n          // Decorate the right of the embedded section\n          appendDecorations(\n              basePos + tokenStart + embeddedSourceEnd,\n              token.substring(embeddedSourceEnd),\n              decorate, decorations);\n        }\n      }\n      job.decorations = decorations;\n    };\n    return decorate;\n  }\n\n  /** returns a function that produces a list of decorations from source text.\n    *\n    * This code treats \", ', and ` as string delimiters, and \\ as a string\n    * escape.  It does not recognize perl's qq() style strings.\n    * It has no special handling for double delimiter escapes as in basic, or\n    * the tripled delimiters used in python, but should work on those regardless\n    * although in those cases a single string literal may be broken up into\n    * multiple adjacent string literals.\n    *\n    * It recognizes C, C++, and shell style comments.\n    *\n    * @param {Object} options a set of optional parameters.\n    * @return {function (Object)} a function that examines the source code\n    *     in the input job and builds the decoration list.\n    */\n  function sourceDecorator(options) {\n    var shortcutStylePatterns = [], fallthroughStylePatterns = [];\n    if (options['tripleQuotedStrings']) {\n      // '''multi-line-string''', 'single-line-string', and double-quoted\n      shortcutStylePatterns.push(\n          [PR_STRING,  /^(?:\\'\\'\\'(?:[^\\'\\\\]|\\\\[\\s\\S]|\\'{1,2}(?=[^\\']))*(?:\\'\\'\\'|$)|\\\"\\\"\\\"(?:[^\\\"\\\\]|\\\\[\\s\\S]|\\\"{1,2}(?=[^\\\"]))*(?:\\\"\\\"\\\"|$)|\\'(?:[^\\\\\\']|\\\\[\\s\\S])*(?:\\'|$)|\\\"(?:[^\\\\\\\"]|\\\\[\\s\\S])*(?:\\\"|$))/,\n           null, '\\'\"']);\n    } else if (options['multiLineStrings']) {\n      // 'multi-line-string', \"multi-line-string\"\n      shortcutStylePatterns.push(\n          [PR_STRING,  /^(?:\\'(?:[^\\\\\\']|\\\\[\\s\\S])*(?:\\'|$)|\\\"(?:[^\\\\\\\"]|\\\\[\\s\\S])*(?:\\\"|$)|\\`(?:[^\\\\\\`]|\\\\[\\s\\S])*(?:\\`|$))/,\n           null, '\\'\"`']);\n    } else {\n      // 'single-line-string', \"single-line-string\"\n      shortcutStylePatterns.push(\n          [PR_STRING,\n           /^(?:\\'(?:[^\\\\\\'\\r\\n]|\\\\.)*(?:\\'|$)|\\\"(?:[^\\\\\\\"\\r\\n]|\\\\.)*(?:\\\"|$))/,\n           null, '\"\\'']);\n    }\n    if (options['verbatimStrings']) {\n      // verbatim-string-literal production from the C# grammar.  See issue 93.\n      fallthroughStylePatterns.push(\n          [PR_STRING, /^@\\\"(?:[^\\\"]|\\\"\\\")*(?:\\\"|$)/, null]);\n    }\n    var hc = options['hashComments'];\n    if (hc) {\n      if (options['cStyleComments']) {\n        if (hc > 1) {  // multiline hash comments\n          shortcutStylePatterns.push(\n              [PR_COMMENT, /^#(?:##(?:[^#]|#(?!##))*(?:###|$)|.*)/, null, '#']);\n        } else {\n          // Stop C preprocessor declarations at an unclosed open comment\n          shortcutStylePatterns.push(\n              [PR_COMMENT, /^#(?:(?:define|elif|else|endif|error|ifdef|include|ifndef|line|pragma|undef|warning)\\b|[^\\r\\n]*)/,\n               null, '#']);\n        }\n        fallthroughStylePatterns.push(\n            [PR_STRING,\n             /^<(?:(?:(?:\\.\\.\\/)*|\\/?)(?:[\\w-]+(?:\\/[\\w-]+)+)?[\\w-]+\\.h|[a-z]\\w*)>/,\n             null]);\n      } else {\n        shortcutStylePatterns.push([PR_COMMENT, /^#[^\\r\\n]*/, null, '#']);\n      }\n    }\n    if (options['cStyleComments']) {\n      fallthroughStylePatterns.push([PR_COMMENT, /^\\/\\/[^\\r\\n]*/, null]);\n      fallthroughStylePatterns.push(\n          [PR_COMMENT, /^\\/\\*[\\s\\S]*?(?:\\*\\/|$)/, null]);\n    }\n    if (options['regexLiterals']) {\n      var REGEX_LITERAL = (\n          // A regular expression literal starts with a slash that is\n          // not followed by * or / so that it is not confused with\n          // comments.\n          '/(?=[^/*])'\n          // and then contains any number of raw characters,\n          + '(?:[^/\\\\x5B\\\\x5C]'\n          // escape sequences (\\x5C),\n          +    '|\\\\x5C[\\\\s\\\\S]'\n          // or non-nesting character sets (\\x5B\\x5D);\n          +    '|\\\\x5B(?:[^\\\\x5C\\\\x5D]|\\\\x5C[\\\\s\\\\S])*(?:\\\\x5D|$))+'\n          // finally closed by a /.\n          + '/');\n      fallthroughStylePatterns.push(\n          ['lang-regex',\n           new RegExp('^' + REGEXP_PRECEDER_PATTERN + '(' + REGEX_LITERAL + ')')\n           ]);\n    }\n\n    var keywords = options['keywords'].replace(/^\\s+|\\s+$/g, '');\n    if (keywords.length) {\n      fallthroughStylePatterns.push(\n          [PR_KEYWORD,\n           new RegExp('^(?:' + keywords.replace(/\\s+/g, '|') + ')\\\\b'), null]);\n    }\n\n    shortcutStylePatterns.push([PR_PLAIN,       /^\\s+/, null, ' \\r\\n\\t\\xA0']);\n    fallthroughStylePatterns.push(\n        // TODO(mikesamuel): recognize non-latin letters and numerals in idents\n        [PR_LITERAL,     /^@[a-z_$][a-z_$@0-9]*/i, null],\n        [PR_TYPE,        /^@?[A-Z]+[a-z][A-Za-z_$@0-9]*/, null],\n        [PR_PLAIN,       /^[a-z_$][a-z_$@0-9]*/i, null],\n        [PR_LITERAL,\n         new RegExp(\n             '^(?:'\n             // A hex number\n             + '0x[a-f0-9]+'\n             // or an octal or decimal number,\n             + '|(?:\\\\d(?:_\\\\d+)*\\\\d*(?:\\\\.\\\\d*)?|\\\\.\\\\d\\\\+)'\n             // possibly in scientific notation\n             + '(?:e[+\\\\-]?\\\\d+)?'\n             + ')'\n             // with an optional modifier like UL for unsigned long\n             + '[a-z]*', 'i'),\n         null, '0123456789'],\n        // Don't treat escaped quotes in bash as starting strings.  See issue 144.\n        [PR_PLAIN,       /^\\\\[\\s\\S]?/, null],\n        [PR_PUNCTUATION, /^.[^\\s\\w\\.$@\\'\\\"\\`\\/\\#\\\\]*/, null]);\n\n    return createSimpleLexer(shortcutStylePatterns, fallthroughStylePatterns);\n  }\n\n  var decorateSource = sourceDecorator({\n        'keywords': ALL_KEYWORDS,\n        'hashComments': true,\n        'cStyleComments': true,\n        'multiLineStrings': true,\n        'regexLiterals': true\n      });\n\n  /**\n   * Given a DOM subtree, wraps it in a list, and puts each line into its own\n   * list item.\n   *\n   * @param {Node} node modified in place.  Its content is pulled into an\n   *     HTMLOListElement, and each line is moved into a separate list item.\n   *     This requires cloning elements, so the input might not have unique\n   *     IDs after numbering.\n   */\n  function numberLines(node, opt_startLineNum) {\n    var nocode = /(?:^|\\s)nocode(?:\\s|$)/;\n    var lineBreak = /\\r\\n?|\\n/;\n  \n    var document = node.ownerDocument;\n  \n    var whitespace;\n    if (node.currentStyle) {\n      whitespace = node.currentStyle.whiteSpace;\n    } else if (window.getComputedStyle) {\n      whitespace = document.defaultView.getComputedStyle(node, null)\n          .getPropertyValue('white-space');\n    }\n    // If it's preformatted, then we need to split lines on line breaks\n    // in addition to <BR>s.\n    var isPreformatted = whitespace && 'pre' === whitespace.substring(0, 3);\n  \n    var li = document.createElement('LI');\n    while (node.firstChild) {\n      li.appendChild(node.firstChild);\n    }\n    // An array of lines.  We split below, so this is initialized to one\n    // un-split line.\n    var listItems = [li];\n  \n    function walk(node) {\n      switch (node.nodeType) {\n        case 1:  // Element\n          if (nocode.test(node.className)) { break; }\n          if ('BR' === node.nodeName) {\n            breakAfter(node);\n            // Discard the <BR> since it is now flush against a </LI>.\n            if (node.parentNode) {\n              node.parentNode.removeChild(node);\n            }\n          } else {\n            for (var child = node.firstChild; child; child = child.nextSibling) {\n              walk(child);\n            }\n          }\n          break;\n        case 3: case 4:  // Text\n          if (isPreformatted) {\n            var text = node.nodeValue;\n            var match = text.match(lineBreak);\n            if (match) {\n              var firstLine = text.substring(0, match.index);\n              node.nodeValue = firstLine;\n              var tail = text.substring(match.index + match[0].length);\n              if (tail) {\n                var parent = node.parentNode;\n                parent.insertBefore(\n                    document.createTextNode(tail), node.nextSibling);\n              }\n              breakAfter(node);\n              if (!firstLine) {\n                // Don't leave blank text nodes in the DOM.\n                node.parentNode.removeChild(node);\n              }\n            }\n          }\n          break;\n      }\n    }\n  \n    // Split a line after the given node.\n    function breakAfter(lineEndNode) {\n      // If there's nothing to the right, then we can skip ending the line\n      // here, and move root-wards since splitting just before an end-tag\n      // would require us to create a bunch of empty copies.\n      while (!lineEndNode.nextSibling) {\n        lineEndNode = lineEndNode.parentNode;\n        if (!lineEndNode) { return; }\n      }\n  \n      function breakLeftOf(limit, copy) {\n        // Clone shallowly if this node needs to be on both sides of the break.\n        var rightSide = copy ? limit.cloneNode(false) : limit;\n        var parent = limit.parentNode;\n        if (parent) {\n          // We clone the parent chain.\n          // This helps us resurrect important styling elements that cross lines.\n          // E.g. in <i>Foo<br>Bar</i>\n          // should be rewritten to <li><i>Foo</i></li><li><i>Bar</i></li>.\n          var parentClone = breakLeftOf(parent, 1);\n          // Move the clone and everything to the right of the original\n          // onto the cloned parent.\n          var next = limit.nextSibling;\n          parentClone.appendChild(rightSide);\n          for (var sibling = next; sibling; sibling = next) {\n            next = sibling.nextSibling;\n            parentClone.appendChild(sibling);\n          }\n        }\n        return rightSide;\n      }\n  \n      var copiedListItem = breakLeftOf(lineEndNode.nextSibling, 0);\n      // Walk the parent chain until we reach an unattached LI.\n      for (var parent;\n           // Check nodeType since IE invents document fragments.\n           (parent = copiedListItem.parentNode) && parent.nodeType === 1;) {\n        copiedListItem = parent;\n      }\n      // Put it on the list of lines for later processing.\n      listItems.push(copiedListItem);\n    }\n  \n    // Split lines while there are lines left to split.\n    for (var i = 0;  // Number of lines that have been split so far.\n         i < listItems.length;  // length updated by breakAfter calls.\n         ++i) {\n      walk(listItems[i]);\n    }\n  \n    // Make sure numeric indices show correctly.\n    if (opt_startLineNum === (opt_startLineNum|0)) {\n      listItems[0].setAttribute('value', opt_startLineNum);\n    }\n  \n    var ol = document.createElement('OL');\n    ol.className = 'linenums';\n    var offset = Math.max(0, ((opt_startLineNum - 1 /* zero index */)) | 0) || 0;\n    for (var i = 0, n = listItems.length; i < n; ++i) {\n      li = listItems[i];\n      // Stick a class on the LIs so that stylesheets can\n      // color odd/even rows, or any other row pattern that\n      // is co-prime with 10.\n      li.className = 'L' + ((i + offset) % 10);\n      if (!li.firstChild) {\n        li.appendChild(document.createTextNode('\\xA0'));\n      }\n      ol.appendChild(li);\n    }\n})();\n";
	
	public static final VersionMessage TESTMESSAGE_LINES10 = new VersionMessage(new LongKey(0L), new Source("javascript-10lines.java"), Languages.JAVASCRIPT, LINES10, new ArrayList<Selection>(Arrays.asList(new Selection(269, 0))));
	public static final VersionMessage TESTMESSAGE_LINES100 = new VersionMessage(new LongKey(0L), new Source("javascript-100lines.java"), Languages.JAVASCRIPT, LINES100, new ArrayList<Selection>(Arrays.asList(new Selection(3379, 0))));
	public static final VersionMessage TESTMESSAGE_LINES1000 = new VersionMessage(new LongKey(0L), new Source("javascript-100lines.java"), Languages.JAVASCRIPT, LINES1000, new ArrayList<Selection>(Arrays.asList(new Selection(7145, 0))));
}
