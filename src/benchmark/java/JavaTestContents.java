package benchmark.java;

import java.util.ArrayList;
import java.util.Arrays;

import monto.service.message.Languages;
import monto.service.message.LongKey;
import monto.service.message.Selection;
import monto.service.message.Source;
import monto.service.message.VersionMessage;

public class JavaTestContents {
	
	public static final String LINES10 = "public class Activator extends AbstractUIPlugin {\n\tpublic void stop(BundleContext bundle) throws Exception {\n\t\tsource.close();\n\t\tsink.stop();\n\t\tservers.forEach(server -> server.stop());\n\t\tprofiler.close();\n\t\tplugin = null;\n\t\tsuper.stop(bundle);\n\t}\n}\n";
	public static final String LINES100 = "package de.tudarmstadt.stg.monto;\nimport java.io.BufferedWriter;\nimport java.io.FileWriter;\nimport java.io.PrintWriter;\nimport java.time.LocalDateTime;\nimport java.time.format.DateTimeFormatter;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport org.eclipse.core.runtime.Status;\nimport org.eclipse.ui.plugin.AbstractUIPlugin;\nimport org.osgi.framework.BundleContext;\nimport org.zeromq.ZMQ;\nimport org.zeromq.ZMQ.Context;\nimport de.tudarmstadt.stg.monto.connection.Pair;\nimport de.tudarmstadt.stg.monto.connection.Publish;\nimport de.tudarmstadt.stg.monto.connection.PublishSource;\nimport de.tudarmstadt.stg.monto.connection.Sink;\nimport de.tudarmstadt.stg.monto.connection.Subscribe;\nimport de.tudarmstadt.stg.monto.java8.JavaCodeCompletion;\nimport de.tudarmstadt.stg.monto.java8.JavaOutliner;\nimport de.tudarmstadt.stg.monto.java8.JavaParser;\nimport de.tudarmstadt.stg.monto.java8.JavaTokenizer;\nimport de.tudarmstadt.stg.monto.message.MessageListener;\nimport de.tudarmstadt.stg.monto.message.ProductMessage;\nimport de.tudarmstadt.stg.monto.message.ProductRegistry;\nimport de.tudarmstadt.stg.monto.message.ProductRegistry.ProductItem;\nimport de.tudarmstadt.stg.monto.message.Source;\nimport de.tudarmstadt.stg.monto.message.VersionMessage;\nimport de.tudarmstadt.stg.monto.profiling.Profiler;\nimport de.tudarmstadt.stg.monto.server.Server;\npublic class Activator extends AbstractUIPlugin {\n\tpublic static final String PLUGIN_ID = \"monto\"; //$NON-NLS-1$\n\tprivate static Activator plugin;\n\tprivate Profiler profiler;\n\tprivate List<Server> servers;\n\tprivate Set<MessageListener> messageListeners = new HashSet<>();\n\tprivate ProductRegistry products = new ProductRegistry();\n\tprivate PublishSource source;\n\tprivate Sink sink;\n\tpublic void start(BundleContext bundle) throws Exception {\n\t\tsuper.start(bundle);\n\t\tplugin = this;\n\t\tString profFile = LocalDateTime.now().format(DateTimeFormatter.ofPattern(\"yyyy-MM-dd-kk-mm-ss\"))+\".csv\";\n\t\tprofiler = new Profiler(new PrintWriter(new BufferedWriter(new FileWriter(profFile))));\n\t\tContext ctx = ZMQ.context(1);\n\t\tsource = new PublishSource(new Publish(ctx, \"tcp://localhost:5000\"));\n\t\tsource.connect();\n\t\tsink = new Sink(new Subscribe(ctx, \"tcp://localhost:5001\")) {\n\t\t\t@Override public void onMessage(ProductMessage msg) {\n\t\t\t\tfor(MessageListener listener : messageListeners)\n\t\t\t\t\tlistener.onMessage(msg);\n\t\t\t\tproducts.registerProduct(msg.getSource(),msg.getProduct(),msg.getLanguage());\n\t\t\t}\n\t\t};\n\t\tsink.fork();\n\t\tservers = Arrays.asList(\n\t\t\t\tnew JavaTokenizer(new Pair(ctx, \"tcp://localhost:5010\")),\n\t\t\t\tnew JavaParser(new Pair(ctx, \"tcp://localhost:5011\")),\n\t\t\t\tnew JavaOutliner(new Pair(ctx, \"tcp://localhost:5012\")),\n\t\t\t\tnew JavaCodeCompletion(new Pair(ctx, \"tcp://localhost:5013\"))\n\t\t\t\t//new JsonPrettyPrinter(new Connection(ctx, \"tcp://localhost:5004\"))\n\t\t\t\t);\n\t\tservers.forEach(server -> server.fork());\n\t}\n\tpublic void stop(BundleContext bundle) throws Exception {\n\t\tsource.close();\n\t\tsink.stop();\n\t\tservers.forEach(server -> server.stop());\n\t\tprofiler.close();\n\t\tplugin = null;\n\t\tsuper.stop(bundle);\n        s\n\t}\n\tpublic static Activator getDefault() {\n\t\treturn plugin;\n\t}\n\tpublic static Profiler getProfiler() {\n\t\treturn getDefault().profiler;\n\t}\n\tpublic static void debug(String msg, Object ... formatArgs) {\n\t\tgetDefault().getLog().log(new Status(Status.INFO, PLUGIN_ID, String.format(msg,formatArgs)));\n\t}\n\tpublic static void error(Exception e) {\n\t\terror(null, e);\n\t}\n\tpublic static void error(String msg, Exception e) {\n\t\tgetDefault().getLog().log(new Status(Status.ERROR, PLUGIN_ID, msg, e));\n\t}\n\tpublic static void addMessageListener(MessageListener listener) {\n\t\tgetDefault().messageListeners.add(listener);\n\t}\n\tpublic static void removeMessageListener(MessageListener listener) {\n\t\tgetDefault().messageListeners.remove(listener);\n\t}\n\tpublic static void sendMessage(VersionMessage version) {\n\t\tgetDefault().source.sendMessage(version);\n\t}\n\n}\n";
	public static final String LINES1000 = "package monto.service;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.json.simple.JSONArray;\nimport org.json.simple.JSONObject;\nimport org.json.simple.JSONValue;\nimport org.zeromq.ZMQ;\nimport org.zeromq.ZMQ.Socket;\n\nimport monto.service.configuration.Option;\nimport monto.service.message.ConfigurationMessage;\nimport monto.service.message.ConfigurationMessages;\nimport monto.service.message.DeregisterService;\nimport monto.service.message.Language;\nimport monto.service.message.LongKey;\nimport monto.service.message.Message;\nimport monto.service.message.ParseException;\nimport monto.service.message.Product;\nimport monto.service.message.ProductDependency;\nimport monto.service.message.ProductMessages;\nimport monto.service.message.RegisterMessages;\nimport monto.service.message.RegisterServiceRequest;\nimport monto.service.message.RegisterServiceResponse;\nimport monto.service.message.ServiceID;\nimport monto.service.message.Source;\nimport monto.service.message.VersionMessages;\nimport monto.service.util.PartialConsumer;\nimport monto.service.util.PartialFunction;\nimport java.io.BufferedWriter;\nimport java.io.FileWriter;\nimport java.io.PrintWriter;\nimport java.time.LocalDateTime;\nimport java.time.format.DateTimeFormatter;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport org.eclipse.core.runtime.Status;\nimport org.eclipse.ui.plugin.AbstractUIPlugin;\nimport org.osgi.framework.BundleContext;\nimport org.zeromq.ZMQ;\nimport org.zeromq.ZMQ.Context;\nimport de.tudarmstadt.stg.monto.connection.Pair;\nimport de.tudarmstadt.stg.monto.connection.Publish;\nimport de.tudarmstadt.stg.monto.connection.PublishSource;\nimport de.tudarmstadt.stg.monto.connection.Sink;\nimport de.tudarmstadt.stg.monto.connection.Subscribe;\nimport de.tudarmstadt.stg.monto.java8.JavaCodeCompletion;\nimport de.tudarmstadt.stg.monto.java8.JavaOutliner;\nimport de.tudarmstadt.stg.monto.java8.JavaParser;\nimport de.tudarmstadt.stg.monto.java8.JavaTokenizer;\nimport de.tudarmstadt.stg.monto.message.MessageListener;\nimport de.tudarmstadt.stg.monto.message.ProductMessage;\nimport de.tudarmstadt.stg.monto.message.ProductRegistry;\nimport de.tudarmstadt.stg.monto.message.ProductRegistry.ProductItem;\nimport de.tudarmstadt.stg.monto.message.Source;\nimport de.tudarmstadt.stg.monto.message.VersionMessage;\nimport de.tudarmstadt.stg.monto.profiling.Profiler;\nimport de.tudarmstadt.stg.monto.server.Server;\n\n/**\n * Template for a monto service.\n */\n@SuppressWarnings(\"rawtypes\")\npublic abstract class MontoService {\n\n    private ZMQConfiguration zmqConfig;\n    private int port;\n    private volatile boolean running;\n    private boolean registered;\n\n    protected volatile ServiceID serviceID;\n    protected volatile String label;\n    protected volatile String description;\n    protected volatile Language language;\n    protected volatile Product product;\n\tprotected volatile Option[] options;\n    protected volatile String[] dependencies;\n\tprivate Socket registrationSocket;\n\tprivate Socket serviceSocket;\n\tprivate Thread serviceThread;\n\tprivate Thread configThread;\n\tprivate Socket configSocket;\n\n    /**\n     * Template for a monto service.\n     *\n     * @param context\n     * @param fullServiceAddress             address of the service without port, e.g. \"tcp://*\"\n     * @param registrationAddress registration address of the broker, e.g. \"tcp://*:5004\"\n     * @param serviceID\n     * @param product\n     * @param language\n     * @param dependencies\n     */\n    public MontoService(\n    \t\tZMQConfiguration zmqConfig,\n    \t\tServiceID serviceID,\n    \t\tString label,\n    \t\tString description,\n    \t\tProduct product,\n    \t\tLanguage language,\n    \t\tString[] dependencies\n    \t\t) {\n    \tthis.zmqConfig = zmqConfig;\n        this.serviceID = serviceID;\n        this.label = label;\n        this.description = description;\n        this.language = language;\n        this.product = product;\n        this.options = new Option[]{};\n        this.dependencies = dependencies;\n        this.running = true;\n        this.registered = false;\n    }\n\n    /**\n     * Template for a monto service with options.\n     *\n     * @param context\n     * @param fullServiceAddress             address of the service without port, e.g. \"tcp://*\"\n     * @param registrationAddress registration address of the broker, e.g. \"tcp://*:5004\"\n     * @param serviceID\n     * @param label\n     * @param description\n     * @param language\n     * @param product\n     * @param options\n     * @param dependencies\n     */\n    public MontoService(ZMQConfiguration zmqConfig, ServiceID serviceID, String label, String description, Language language, Product product, Option[] options, String[] dependencies) {\n        this(zmqConfig, serviceID, label, description, product, language, dependencies);\n        this.options = options;\n    }\n\n    public <MSG,Decoded> void handleMessage(Socket socket, PartialFunction<MSG,Decoded,ParseException> decodeMessage, PartialConsumer<Decoded, ? super Exception> onMessage) {\n    \tString rawMsg = socket.recvStr();\n\t\ttry {\n\t\t\t// In case of subscription ignore topic and receive message body\n\t\t\tif(socket.getType() == ZMQ.SUB && rawMsg != null)\n\t\t\t\trawMsg = socket.recvStr();\n\n\t\t\tif (rawMsg != null) {\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tMSG msg = (MSG) JSONValue.parseWithException(rawMsg);\n\t\t\t\tDecoded decoded = decodeMessage.apply(msg);\n\t\t\t\tonMessage.accept(decoded);\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tSystem.err.printf(\"An exception occured during handling the message %s\\n\",rawMsg);\n\t\t\te.printStackTrace();\n\t\t}\n    }\n    \n    public void start() {\n        registerService();\n        if (isRegisterResponseOk()) {\n        \trunning = true;\n        \tserviceSocket = zmqConfig.getContext().createSocket(ZMQ.PAIR);\n        \tserviceSocket.connect(zmqConfig.getServiceAddress() + \":\" + port);\n        \tserviceSocket.setReceiveTimeOut(500);\n        \tMontoService that = this;\n        \tserviceThread = new Thread() {\n        \t\t@Override\n        \t\tpublic void run() {\n        \t\t\twhile(running)\n        \t\t\t\tthat.<JSONArray,List<Message>>handleMessage (\n        \t\t\t\t\t\tserviceSocket,\n        \t\t\t\t\t\tmessages -> {\n        \t\t\t\t\t\t\tList<Message> decodedMessages = new ArrayList<>();\n        \t\t\t\t\t\t\tfor (Object object : messages) {\n        \t\t\t\t\t\t\t\tJSONObject message = (JSONObject) object;\n        \t\t\t\t\t\t\t\tdecodedMessages.add(message.containsKey(\"product\") ? ProductMessages.decode(message) : VersionMessages.decode(message));\n        \t\t\t\t\t\t\t}\n        \t\t\t\t\t\t\treturn decodedMessages;\n        \t\t\t\t\t\t},\n        \t\t\t\t\t\tmessages -> serviceSocket.send(ProductMessages.encode(onVersionMessage(messages)).toJSONString()));\n        \t\t}\n        \t};\n        \tserviceThread.start();\n        \t\n        \tconfigSocket = zmqConfig.getContext().createSocket(ZMQ.SUB);\n        \tconfigSocket.connect(zmqConfig.getConfigurationAddress());\n        \tconfigSocket.subscribe(serviceID.toString().getBytes());\n        \tconfigSocket.setReceiveTimeOut(500);\n        \tconfigThread = new Thread() {\n        \t\t@Override\n        \t\tpublic void run() {\n        \t\t\twhile(running) {\n        \t\t\t\tthat.<JSONObject,ConfigurationMessage>handleMessage(\n        \t\t\t\t\t\tconfigSocket,\n        \t\t\t\t\t\tConfigurationMessages::decode,\n        \t\t\t\t\t\tmessage -> onConfigurationMessage(message));\n        \t\t\t}s\n        \t\t};\n        \t};\n        \tconfigThread.start();\n        \tSystem.out.println(\"connected: \" + serviceID);\n        }\n    }\n\n    public void stop() {\n        if (registered == true) {\n            running = false;\n            System.out.println(\"disconnecting: \" + serviceID);\n            System.out.println(\"deregistering: \" + serviceID);\n            try {\n\t\t\t\tserviceThread.join();\n\t\t\t\tconfigThread.join();\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n            registrationSocket.send(RegisterMessages.encode(new DeregisterService(serviceID)).toJSONString());\n            \n            // Sockets will be closed by ZContext.destroy()\n            \n            System.out.println(\"terminated: \" + serviceID);\n        }\n    }\n\n    private void registerService() {\n        System.out.println(\"registering: \" + serviceID + \" on \" + zmqConfig.getRegistrationAddress());\n        registrationSocket = zmqConfig.getContext().createSocket(ZMQ.REQ);\n        registrationSocket.connect(zmqConfig.getRegistrationAddress());\n        registrationSocket.send(RegisterMessages.encode(new RegisterServiceRequest(serviceID, label, description, language, product, options, dependencies)).toJSONString());\n    }\n\n    private boolean isRegisterResponseOk() {\n        JSONObject response = (JSONObject) JSONValue.parse(registrationSocket.recvStr());\n        RegisterServiceResponse decodedResponse = RegisterMessages.decodeResponse(response);\n        if (decodedResponse.getResponse().equals(\"ok\") && decodedResponse.getBindOnPort() > -1) {\n            port = decodedResponse.getBindOnPort();\n            System.out.println(\"registered: \" + serviceID + \", connecting on \" + zmqConfig.getServiceAddress() + \":\" + port);\n            registered = true;\n            return true;\n        }\n        System.out.printf(\"could not register service %s: %s\\n\", serviceID, decodedResponse.getResponse());\n        return false;\n    }\n    \n    protected ProductMessage productMessage(LongKey versionID, Source source, Object contents, ProductDependency ... deps) {\n        return new ProductMessage(\n                versionID,\n                source,\n                getServiceID(),\n                getProduct(),\n                getLanguage(),\n                contents,\n                deps);\n    }\n\n    /**\n     * It handles the version messages from the broker and determines the response.\n     *\n     * @param messages VersionMessage an dependency ProductMessages\n     * @return a ProductMessage for the service\n     * @throws Exception\n     */\n    public abstract ProductMessage onVersionMessage(List<Message> messages) throws Exception;\n\n    /**\n     * It handles the configuration messages from the broker and determines the response.\n     *\n     * @param message The received configuration message\n     * @throws Exception\n     */\n    public void onConfigurationMessage(ConfigurationMessage message) throws Exception {\n    \t// By default ignore configuration messages.\n    }\n\n    public ServiceID getServiceID() {\n        return serviceID;\n    }\n\n    public Language getLanguage() {\n        return language;\n    }\n\n    public Product getProduct() {\n        return product;\n    }\n\n    public String[] getDependencies() {\n        return dependencies;\n    }\n\n    public Option[] getOptions() {\n        return options;\n    }\n\n private class Activator extends AbstractUIPlugin {\n\tpublic static final String PLUGIN_ID = \"monto\"; //$NON-NLS-1$\n\tprivate static Activator plugin;\n\tprivate Profiler profiler;\n\tprivate List<Server> servers;\n\tprivate Set<MessageListener> messageListeners = new HashSet<>();\n\tprivate ProductRegistry products = new ProductRegistry();\n\tprivate PublishSource source;\n\tprivate Sink sink;\n\tpublic void start(BundleContext bundle) throws Exception {\n\t\tsuper.start(bundle);\n\t\tplugin = this;\n\t\tString profFile = LocalDateTime.now().format(DateTimeFormatter.ofPattern(\"yyyy-MM-dd-kk-mm-ss\"))+\".csv\";\n\t\tprofiler = new Profiler(new PrintWriter(new BufferedWriter(new FileWriter(profFile))));\n\t\tContext ctx = ZMQ.context(1);\n\t\tsource = new PublishSource(new Publish(ctx, \"tcp://localhost:5000\"));\n\t\tsource.connect();\n\t\tsink = new Sink(new Subscribe(ctx, \"tcp://localhost:5001\")) {\n\t\t\t@Override public void onMessage(ProductMessage msg) {\n\t\t\t\tfor(MessageListener listener : messageListeners)\n\t\t\t\t\tlistener.onMessage(msg);\n\t\t\t\tproducts.registerProduct(msg.getSource(),msg.getProduct(),msg.getLanguage());\n\t\t\t}\n\t\t};\n\t\tsink.fork();\n\t\tservers = Arrays.asList(\n\t\t\t\tnew JavaTokenizer(new Pair(ctx, \"tcp://localhost:5010\")),\n\t\t\t\tnew JavaParser(new Pair(ctx, \"tcp://localhost:5011\")),\n\t\t\t\tnew JavaOutliner(new Pair(ctx, \"tcp://localhost:5012\")),\n\t\t\t\tnew JavaCodeCompletion(new Pair(ctx, \"tcp://localhost:5013\"))\n\t\t\t\t//new JsonPrettyPrinter(new Connection(ctx, \"tcp://localhost:5004\"))\n\t\t\t\t);\n\t\tservers.forEach(server -> server.fork());\n\t}\n\tpublic void stop(BundleContext bundle) throws Exception {\n\t\tsource.close();\n\t\tsink.stop();\n\t\tservers.forEach(server -> server.stop());\n\t\tprofiler.close();\n\t\tplugin = null;\n\t\tsuper.stop(bundle);\n\t}\n\tpublic static Activator getDefault() {\n\t\treturn plugin;\n\t}\n\tpublic static Profiler getProfiler() {\n\t\treturn getDefault().profiler;\n\t}\n\tpublic static void debug(String msg, Object ... formatArgs) {\n\t\tgetDefault().getLog().log(new Status(Status.INFO, PLUGIN_ID, String.format(msg,formatArgs)));\n\t}\n\tpublic static void error(Exception e) {\n\t\terror(null, e);\n\t}\n\tpublic static void error(String msg, Exception e) {\n\t\tgetDefault().getLog().log(new Status(Status.ERROR, PLUGIN_ID, msg, e));\n\t}\n\tpublic static void addMessageListener(MessageListener listener) {\n\t\tgetDefault().messageListeners.add(listener);\n\t}\n\tpublic static void removeMessageListener(MessageListener listener) {\n\t\tgetDefault().messageListeners.remove(listener);\n\t}\n\tpublic static void sendMessage(VersionMessage version) {\n\t\tgetDefault().source.sendMessage(version);\n\t}\n\n}\nprivate class Activator2 extends AbstractUIPlugin {\n\tpublic static final String PLUGIN_ID = \"monto\"; //$NON-NLS-1$\n\tprivate static Activator plugin;\n\tprivate Profiler profiler;\n\tprivate List<Server> servers;\n\tprivate Set<MessageListener> messageListeners = new HashSet<>();\n\tprivate ProductRegistry products = new ProductRegistry();\n\tprivate PublishSource source;\n\tprivate Sink sink;\n\tpublic void start(BundleContext bundle) throws Exception {\n\t\tsuper.start(bundle);\n\t\tplugin = this;\n\t\tString profFile = LocalDateTime.now().format(DateTimeFormatter.ofPattern(\"yyyy-MM-dd-kk-mm-ss\"))+\".csv\";\n\t\tprofiler = new Profiler(new PrintWriter(new BufferedWriter(new FileWriter(profFile))));\n\t\tContext ctx = ZMQ.context(1);\n\t\tsource = new PublishSource(new Publish(ctx, \"tcp://localhost:5000\"));\n\t\tsource.connect();\n\t\tsink = new Sink(new Subscribe(ctx, \"tcp://localhost:5001\")) {\n\t\t\t@Override public void onMessage(ProductMessage msg) {\n\t\t\t\tfor(MessageListener listener : messageListeners)\n\t\t\t\t\tlistener.onMessage(msg);\n\t\t\t\tproducts.registerProduct(msg.getSource(),msg.getProduct(),msg.getLanguage());\n\t\t\t}\n\t\t};\n\t\tsink.fork();\n\t\tservers = Arrays.asList(\n\t\t\t\tnew JavaTokenizer(new Pair(ctx, \"tcp://localhost:5010\")),\n\t\t\t\tnew JavaParser(new Pair(ctx, \"tcp://localhost:5011\")),\n\t\t\t\tnew JavaOutliner(new Pair(ctx, \"tcp://localhost:5012\")),\n\t\t\t\tnew JavaCodeCompletion(new Pair(ctx, \"tcp://localhost:5013\"))\n\t\t\t\t//new JsonPrettyPrinter(new Connection(ctx, \"tcp://localhost:5004\"))\n\t\t\t\t);\n\t\tservers.forEach(server -> server.fork());\n\t}\n\tpublic void stop(BundleContext bundle) throws Exception {\n\t\tsource.close();\n\t\tsink.stop();\n\t\tservers.forEach(server -> server.stop());\n\t\tprofiler.close();\n\t\tplugin = null;\n\t\tsuper.stop(bundle);\n\t}\n\tpublic static Activator getDefault() {\n\t\treturn plugin;\n\t}\n\tpublic static Profiler getProfiler() {\n\t\treturn getDefault().profiler;\n\t}\n\tpublic static void debug(String msg, Object ... formatArgs) {\n\t\tgetDefault().getLog().log(new Status(Status.INFO, PLUGIN_ID, String.format(msg,formatArgs)));\n\t}\n\tpublic static void error(Exception e) {\n\t\terror(null, e);\n\t}\n\tpublic static void error(String msg, Exception e) {\n\t\tgetDefault().getLog().log(new Status(Status.ERROR, PLUGIN_ID, msg, e));\n\t}\n\tpublic static void addMessageListener(MessageListener listener) {\n\t\tgetDefault().messageListeners.add(listener);\n\t}\n\tpublic static void removeMessageListener(MessageListener listener) {\n\t\tgetDefault().messageListeners.remove(listener);\n\t}\n\tpublic static void sendMessage(VersionMessage version) {\n\t\tgetDefault().source.sendMessage(version);\n\t}\n\n}\nprivate class Activator3 extends AbstractUIPlugin {\n\tpublic static final String PLUGIN_ID = \"monto\"; //$NON-NLS-1$\n\tprivate static Activator plugin;\n\tprivate Profiler profiler;\n\tprivate List<Server> servers;\n\tprivate Set<MessageListener> messageListeners = new HashSet<>();\n\tprivate ProductRegistry products = new ProductRegistry();\n\tprivate PublishSource source;\n\tprivate Sink sink;\n\tpublic void start(BundleContext bundle) throws Exception {\n\t\tsuper.start(bundle);\n\t\tplugin = this;\n\t\tString profFile = LocalDateTime.now().format(DateTimeFormatter.ofPattern(\"yyyy-MM-dd-kk-mm-ss\"))+\".csv\";\n\t\tprofiler = new Profiler(new PrintWriter(new BufferedWriter(new FileWriter(profFile))));\n\t\tContext ctx = ZMQ.context(1);\n\t\tsource = new PublishSource(new Publish(ctx, \"tcp://localhost:5000\"));\n\t\tsource.connect();\n\t\tsink = new Sink(new Subscribe(ctx, \"tcp://localhost:5001\")) {\n\t\t\t@Override public void onMessage(ProductMessage msg) {\n\t\t\t\tfor(MessageListener listener : messageListeners)\n\t\t\t\t\tlistener.onMessage(msg);\n\t\t\t\tproducts.registerProduct(msg.getSource(),msg.getProduct(),msg.getLanguage());\n\t\t\t}\n\t\t};\n\t\tsink.fork();\n\t\tservers = Arrays.asList(\n\t\t\t\tnew JavaTokenizer(new Pair(ctx, \"tcp://localhost:5010\")),\n\t\t\t\tnew JavaParser(new Pair(ctx, \"tcp://localhost:5011\")),\n\t\t\t\tnew JavaOutliner(new Pair(ctx, \"tcp://localhost:5012\")),\n\t\t\t\tnew JavaCodeCompletion(new Pair(ctx, \"tcp://localhost:5013\"))\n\t\t\t\t//new JsonPrettyPrinter(new Connection(ctx, \"tcp://localhost:5004\"))\n\t\t\t\t);\n\t\tservers.forEach(server -> server.fork());\n\t}\n\tpublic void stop(BundleContext bundle) throws Exception {\n\t\tsource.close();\n\t\tsink.stop();\n\t\tservers.forEach(server -> server.stop());\n\t\tprofiler.close();\n\t\tplugin = null;\n\t\tsuper.stop(bundle);\n\t}\n\tpublic static Activator getDefault() {\n\t\treturn plugin;\n\t}\n\tpublic static Profiler getProfiler() {\n\t\treturn getDefault().profiler;\n\t}\n\tpublic static void debug(String msg, Object ... formatArgs) {\n\t\tgetDefault().getLog().log(new Status(Status.INFO, PLUGIN_ID, String.format(msg,formatArgs)));\n\t}\n\tpublic static void error(Exception e) {\n\t\terror(null, e);\n\t}\n\tpublic static void error(String msg, Exception e) {\n\t\tgetDefault().getLog().log(new Status(Status.ERROR, PLUGIN_ID, msg, e));\n\t}\n\tpublic static void addMessageListener(MessageListener listener) {\n\t\tgetDefault().messageListeners.add(listener);\n\t}\n\tpublic static void removeMessageListener(MessageListener listener) {\n\t\tgetDefault().messageListeners.remove(listener);\n\t}\n\tpublic static void sendMessage(VersionMessage version) {\n\t\tgetDefault().source.sendMessage(version);\n\t}\n\n}\nprivate class Activator4 extends AbstractUIPlugin {\n\tpublic static final String PLUGIN_ID = \"monto\"; //$NON-NLS-1$\n\tprivate static Activator plugin;\n\tprivate Profiler profiler;\n\tprivate List<Server> servers;\n\tprivate Set<MessageListener> messageListeners = new HashSet<>();\n\tprivate ProductRegistry products = new ProductRegistry();\n\tprivate PublishSource source;\n\tprivate Sink sink;\n\tpublic void start(BundleContext bundle) throws Exception {\n\t\tsuper.start(bundle);\n\t\tplugin = this;\n\t\tString profFile = LocalDateTime.now().format(DateTimeFormatter.ofPattern(\"yyyy-MM-dd-kk-mm-ss\"))+\".csv\";\n\t\tprofiler = new Profiler(new PrintWriter(new BufferedWriter(new FileWriter(profFile))));\n\t\tContext ctx = ZMQ.context(1);\n\t\tsource = new PublishSource(new Publish(ctx, \"tcp://localhost:5000\"));\n\t\tsource.connect();\n\t\tsink = new Sink(new Subscribe(ctx, \"tcp://localhost:5001\")) {\n\t\t\t@Override public void onMessage(ProductMessage msg) {\n\t\t\t\tfor(MessageListener listener : messageListeners)\n\t\t\t\t\tlistener.onMessage(msg);\n\t\t\t\tproducts.registerProduct(msg.getSource(),msg.getProduct(),msg.getLanguage());\n\t\t\t}\n\t\t};\n\t\tsink.fork();\n\t\tservers = Arrays.asList(\n\t\t\t\tnew JavaTokenizer(new Pair(ctx, \"tcp://localhost:5010\")),\n\t\t\t\tnew JavaParser(new Pair(ctx, \"tcp://localhost:5011\")),\n\t\t\t\tnew JavaOutliner(new Pair(ctx, \"tcp://localhost:5012\")),\n\t\t\t\tnew JavaCodeCompletion(new Pair(ctx, \"tcp://localhost:5013\"))\n\t\t\t\t//new JsonPrettyPrinter(new Connection(ctx, \"tcp://localhost:5004\"))\n\t\t\t\t);\n\t\tservers.forEach(server -> server.fork());\n\t}\n\tpublic void stop(BundleContext bundle) throws Exception {\n\t\tsource.close();\n\t\tsink.stop();\n\t\tservers.forEach(server -> server.stop());\n\t\tprofiler.close();\n\t\tplugin = null;\n\t\tsuper.stop(bundle);\n\t}\n\tpublic static Activator getDefault() {\n\t\treturn plugin;\n\t}\n\tpublic static Profiler getProfiler() {\n\t\treturn getDefault().profiler;\n\t}\n\tpublic static void debug(String msg, Object ... formatArgs) {\n\t\tgetDefault().getLog().log(new Status(Status.INFO, PLUGIN_ID, String.format(msg,formatArgs)));\n\t}\n\tpublic static void error(Exception e) {\n\t\terror(null, e);\n\t}\n\tpublic static void error(String msg, Exception e) {\n\t\tgetDefault().getLog().log(new Status(Status.ERROR, PLUGIN_ID, msg, e));\n\t}\n\tpublic static void addMessageListener(MessageListener listener) {\n\t\tgetDefault().messageListeners.add(listener);\n\t}\n\tpublic static void removeMessageListener(MessageListener listener) {\n\t\tgetDefault().messageListeners.remove(listener);\n\t}\n\tpublic static void sendMessage(VersionMessage version) {\n\t\tgetDefault().source.sendMessage(version);\n\t}\n\n}\nprivate class Activator5 extends AbstractUIPlugin {\n\tpublic static final String PLUGIN_ID = \"monto\"; //$NON-NLS-1$\n\tprivate static Activator plugin;\n\tprivate Profiler profiler;\n\tprivate List<Server> servers;\n\tprivate Set<MessageListener> messageListeners = new HashSet<>();\n\tprivate ProductRegistry products = new ProductRegistry();\n\tprivate PublishSource source;\n\tprivate Sink sink;\n\tpublic void start(BundleContext bundle) throws Exception {\n\t\tsuper.start(bundle);\n\t\tplugin = this;\n\t\tString profFile = LocalDateTime.now().format(DateTimeFormatter.ofPattern(\"yyyy-MM-dd-kk-mm-ss\"))+\".csv\";\n\t\tprofiler = new Profiler(new PrintWriter(new BufferedWriter(new FileWriter(profFile))));\n\t\tContext ctx = ZMQ.context(1);\n\t\tsource = new PublishSource(new Publish(ctx, \"tcp://localhost:5000\"));\n\t\tsource.connect();\n\t\tsink = new Sink(new Subscribe(ctx, \"tcp://localhost:5001\")) {\n\t\t\t@Override public void onMessage(ProductMessage msg) {\n\t\t\t\tfor(MessageListener listener : messageListeners)\n\t\t\t\t\tlistener.onMessage(msg);\n\t\t\t\tproducts.registerProduct(msg.getSource(),msg.getProduct(),msg.getLanguage());\n\t\t\t}\n\t\t};\n\t\tsink.fork();\n\t\tservers = Arrays.asList(\n\t\t\t\tnew JavaTokenizer(new Pair(ctx, \"tcp://localhost:5010\")),\n\t\t\t\tnew JavaParser(new Pair(ctx, \"tcp://localhost:5011\")),\n\t\t\t\tnew JavaOutliner(new Pair(ctx, \"tcp://localhost:5012\")),\n\t\t\t\tnew JavaCodeCompletion(new Pair(ctx, \"tcp://localhost:5013\"))\n\t\t\t\t);\n\t\tservers.forEach(server -> server.fork());\n\t}\n\tpublic void stop(BundleContext bundle) throws Exception {\n\t\tsource.close();\n\t\tsink.stop();\n\t\tservers.forEach(server -> server.stop());\n\t\tprofiler.close();\n\t\tplugin = null;\n\t\tsuper.stop(bundle);\n\t}\n\tpublic static Activator getDefault() {\n\t\treturn plugin;\n\t}\n\tpublic static Profiler getProfiler() {\n\t\treturn getDefault().profiler;\n\t}\n\tpublic static void debug(String msg, Object ... formatArgs) {\n\t\tgetDefault().getLog().log(new Status(Status.INFO, PLUGIN_ID, String.format(msg,formatArgs)));\n\t}\n\tpublic static void error(Exception e) {\n\t\terror(null, e);\n\t}\n\tpublic static void error(String msg, Exception e) {\n\t\tgetDefault().getLog().log(new Status(Status.ERROR, PLUGIN_ID, msg, e));\n\t}\n\tpublic static void addMessageListener(MessageListener listener) {\n\t\tgetDefault().messageListeners.add(listener);\n\t}\n\tpublic static void removeMessageListener(MessageListener listener) {\n\t\tgetDefault().messageListeners.remove(listener);\n\t}\n\tpublic static void sendMessage(VersionMessage version) {\n\t\tgetDefault().source.sendMessage(version);\n\t}\n\n}\nprivate class Activator6 extends AbstractUIPlugin {\n\tpublic static final String PLUGIN_ID = \"monto\"; //$NON-NLS-1$\n\tprivate static Activator plugin;\n\tprivate Profiler profiler;\n\tprivate List<Server> servers;\n\tprivate Set<MessageListener> messageListeners = new HashSet<>();\n\tprivate ProductRegistry products = new ProductRegistry();\n\tprivate PublishSource source;\n\tprivate Sink sink;\n\tpublic void start(BundleContext bundle) throws Exception {\n\t\tsuper.start(bundle);\n\t\tplugin = this;\n\t\tString profFile = LocalDateTime.now().format(DateTimeFormatter.ofPattern(\"yyyy-MM-dd-kk-mm-ss\"))+\".csv\";\n\t\tprofiler = new Profiler(new PrintWriter(new BufferedWriter(new FileWriter(profFile))));\n\t\tContext ctx = ZMQ.context(1);\n\t\tsource = new PublishSource(new Publish(ctx, \"tcp://localhost:5000\"));\n\t\tsource.connect();\n\t\tsink = new Sink(new Subscribe(ctx, \"tcp://localhost:5001\")) {\n\t\t\t@Override public void onMessage(ProductMessage msg) {\n\t\t\t\tfor(MessageListener listener : messageListeners)\n\t\t\t\t\tlistener.onMessage(msg);\n\t\t\t\tproducts.registerProduct(msg.getSource(),msg.getProduct(),msg.getLanguage());\n\t\t\t}\n\t\t};\n\t\tsink.fork();\n\t\tservers = Arrays.asList(\n\t\t\t\tnew JavaTokenizer(new Pair(ctx, \"tcp://localhost:5010\")),\n\t\t\t\tnew JavaParser(new Pair(ctx, \"tcp://localhost:5011\")),\n\t\t\t\tnew JavaOutliner(new Pair(ctx, \"tcp://localhost:5012\")),\n\t\t\t\tnew JavaCodeCompletion(new Pair(ctx, \"tcp://localhost:5013\"))\n\t\t\t\t);\n\t\tservers.forEach(server -> server.fork());\n\t}\n\tpublic void stop(BundleContext bundle) throws Exception {\n\t\tsource.close();\n\t\tsink.stop();\n\t\tservers.forEach(server -> server.stop());\n\t\tprofiler.close();\n\t\tplugin = null;\n\t\tsuper.stop(bundle);\n\t}\n\tpublic static Activator getDefault() {\n\t\treturn plugin;\n\t}\n\tpublic static Profiler getProfiler() {\n\t\treturn getDefault().profiler;\n\t}\n\tpublic static void debug(String msg, Object ... formatArgs) {\n\t\tgetDefault().getLog().log(new Status(Status.INFO, PLUGIN_ID, String.format(msg,formatArgs)));\n\t}\n\tpublic static void error(Exception e) {\n\t\terror(null, e);\n\t}\n\tpublic static void error(String msg, Exception e) {\n\t\tgetDefault().getLog().log(new Status(Status.ERROR, PLUGIN_ID, msg, e));\n\t}\n\tpublic static void addMessageListener(MessageListener listener) {\n\t\tgetDefault().messageListeners.add(listener);\n\t}\n\tpublic static void removeMessageListener(MessageListener listener) {\n\t\tgetDefault().messageListeners.remove(listener);\n\t}\n\tpublic static void sendMessage(VersionMessage version) {\n\t\tgetDefault().source.sendMessage(version);\n\t}\n\n}\nprivate class Activator7 extends AbstractUIPlugin {\n\tpublic static final String PLUGIN_ID = \"monto\"; //$NON-NLS-1$\n\tprivate static Activator plugin;\n\tprivate Profiler profiler;\n\tprivate List<Server> servers;\n\tprivate Set<MessageListener> messageListeners = new HashSet<>();\n\tprivate ProductRegistry products = new ProductRegistry();\n\tprivate PublishSource source;\n\tprivate Sink sink;\n\tpublic void start(BundleContext bundle) throws Exception {\n\t\tsuper.start(bundle);\n\t\tplugin = this;\n\t\tString profFile = LocalDateTime.now().format(DateTimeFormatter.ofPattern(\"yyyy-MM-dd-kk-mm-ss\"))+\".csv\";\n\t\tprofiler = new Profiler(new PrintWriter(new BufferedWriter(new FileWriter(profFile))));\n\t\tContext ctx = ZMQ.context(1);\n\t\tsource = new PublishSource(new Publish(ctx, \"tcp://localhost:5000\"));\n\t\tsource.connect();\n\t\tsink = new Sink(new Subscribe(ctx, \"tcp://localhost:5001\")) {\n\t\t\t@Override public void onMessage(ProductMessage msg) {\n\t\t\t\tfor(MessageListener listener : messageListeners)\n\t\t\t\t\tlistener.onMessage(msg);\n\t\t\t\tproducts.registerProduct(msg.getSource(),msg.getProduct(),msg.getLanguage());\n\t\t\t}\n\t\t};\n\t\tsink.fork();\n\t\tservers = Arrays.asList(\n\t\t\t\tnew JavaTokenizer(new Pair(ctx, \"tcp://localhost:5010\")),\n\t\t\t\tnew JavaParser(new Pair(ctx, \"tcp://localhost:5011\")),\n\t\t\t\tnew JavaOutliner(new Pair(ctx, \"tcp://localhost:5012\")),\n\t\t\t\tnew JavaCodeCompletion(new Pair(ctx, \"tcp://localhost:5013\"))\n\t\t\t\t);\n\t\tservers.forEach(server -> server.fork());\n\t}\n\tpublic void stop(BundleContext bundle) throws Exception {\n\t\tsource.close();\n\t\tsink.stop();\n\t\tservers.forEach(server -> server.stop());\n\t\tprofiler.close();\n\t\tplugin = null;\n\t\tsuper.stop(bundle);\n\t}\n\tpublic static Activator getDefault() {\n\t\treturn plugin;\n\t}\n\tpublic static Profiler getProfiler() {\n\t\treturn getDefault().profiler;\n\t}\n\tpublic static void debug(String msg, Object ... formatArgs) {\n\t\tgetDefault().getLog().log(new Status(Status.INFO, PLUGIN_ID, String.format(msg,formatArgs)));\n\t}\n\tpublic static void error(Exception e) {\n\t\terror(null, e);\n\t}\n\tpublic static void error(String msg, Exception e) {\n\t\tgetDefault().getLog().log(new Status(Status.ERROR, PLUGIN_ID, msg, e));\n\t}\n\tpublic static void addMessageListener(MessageListener listener) {\n\t\tgetDefault().messageListeners.add(listener);\n\t}\n\tpublic static void removeMessageListener(MessageListener listener) {\n\t\tgetDefault().messageListeners.remove(listener);\n\t}\n\tpublic static void sendMessage(VersionMessage version) {\n\t\tgetDefault().source.sendMessage(version);\n\t}\n\n}\nprivate class Activator8 extends AbstractUIPlugin {\n\tpublic static final String PLUGIN_ID = \"monto\"; //$NON-NLS-1$\n\tprivate static Activator plugin;\n\tprivate Profiler profiler;\n\tprivate List<Server> servers;\n\tprivate Set<MessageListener> messageListeners = new HashSet<>();\n\tprivate ProductRegistry products = new ProductRegistry();\n\tprivate PublishSource source;\n\tprivate Sink sink;\n\tpublic void start(BundleContext bundle) throws Exception {\n\t\tsuper.start(bundle);\n\t\tplugin = this;\n\t\tString profFile = LocalDateTime.now().format(DateTimeFormatter.ofPattern(\"yyyy-MM-dd-kk-mm-ss\"))+\".csv\";\n\t\tprofiler = new Profiler(new PrintWriter(new BufferedWriter(new FileWriter(profFile))));\n\t\tContext ctx = ZMQ.context(1);\n\t\tsource = new PublishSource(new Publish(ctx, \"tcp://localhost:5000\"));\n\t\tsource.connect();\n\t\tsink = new Sink(new Subscribe(ctx, \"tcp://localhost:5001\")) {\n\t\t\t@Override public void onMessage(ProductMessage msg) {\n\t\t\t\tfor(MessageListener listener : messageListeners)\n\t\t\t\t\tlistener.onMessage(msg);\n\t\t\t\tproducts.registerProduct(msg.getSource(),msg.getProduct(),msg.getLanguage());\n\t\t\t}\n\t\t};\n\t\tsink.fork();\n\t\tservers = Arrays.asList(\n\t\t\t\tnew JavaTokenizer(new Pair(ctx, \"tcp://localhost:5010\")),\n\t\t\t\tnew JavaParser(new Pair(ctx, \"tcp://localhost:5011\")),\n\t\t\t\tnew JavaOutliner(new Pair(ctx, \"tcp://localhost:5012\")),\n\t\t\t\tnew JavaCodeCompletion(new Pair(ctx, \"tcp://localhost:5013\"))\n\t\t\t\t);\n\t\tservers.forEach(server -> server.fork());\n\t}\n\tpublic void stop(BundleContext bundle) throws Exception {\n\t\tsource.close();\n\t\tsink.stop();\n\t\tservers.forEach(server -> server.stop());\n\t\tprofiler.close();\n\t\tplugin = null;\n\t\tsuper.stop(bundle);\n\t}\n\tpublic static Activator getDefault() {\n\t\treturn plugin;\n\t}\n\tpublic static Profiler getProfiler() {\n\t\treturn getDefault().profiler;\n\t}\n\tpublic static void debug(String msg, Object ... formatArgs) {\n\t\tgetDefault().getLog().log(new Status(Status.INFO, PLUGIN_ID, String.format(msg,formatArgs)));\n\t}\n\tpublic static void error(Exception e) {\n\t\terror(null, e);\n\t}\n\tpublic static void error(String msg, Exception e) {\n\t\tgetDefault().getLog().log(new Status(Status.ERROR, PLUGIN_ID, msg, e));\n\t}\n\tpublic static void addMessageListener(MessageListener listener) {\n\t\tgetDefault().messageListeners.add(listener);\n\t}\n\tpublic static void removeMessageListener(MessageListener listener) {\n\t\tgetDefault().messageListeners.remove(listener);\n\t}\n\tpublic static void sendMessage(VersionMessage version) {\n\t\tgetDefault().source.sendMessage(version);\n\t}\n\n}\nprivate class Activator9 extends AbstractUIPlugin {\n\tpublic static final String PLUGIN_ID = \"monto\"; //$NON-NLS-1$\n\tprivate static Activator plugin;\n\tprivate Profiler profiler;\n\tprivate List<Server> servers;\n\tprivate Set<MessageListener> messageListeners = new HashSet<>();\n\tprivate ProductRegistry products = new ProductRegistry();\n\tprivate PublishSource source;\n\tprivate Sink sink;\n\tpublic void start(BundleContext bundle) throws Exception {\n\t\tsuper.start(bundle);\n\t\tplugin = this;\n\t\tString profFile = LocalDateTime.now().format(DateTimeFormatter.ofPattern(\"yyyy-MM-dd-kk-mm-ss\"))+\".csv\";\n\t\tprofiler = new Profiler(new PrintWriter(new BufferedWriter(new FileWriter(profFile))));\n\t\tContext ctx = ZMQ.context(1);\n\t\tsource = new PublishSource(new Publish(ctx, \"tcp://localhost:5000\"));\n\t\tsource.connect();\n\t\tsink = new Sink(new Subscribe(ctx, \"tcp://localhost:5001\")) {\n\t\t\t@Override public void onMessage(ProductMessage msg) {\n\t\t\t\tfor(MessageListener listener : messageListeners)\n\t\t\t\t\tlistener.onMessage(msg);\n\t\t\t\tproducts.registerProduct(msg.getSource(),msg.getProduct(),msg.getLanguage());\n\t\t\t}\n\t\t};\n\t\tsink.fork();\n\t\tservers = Arrays.asList(\n\t\t\t\tnew JavaTokenizer(new Pair(ctx, \"tcp://localhost:5010\")),\n\t\t\t\tnew JavaParser(new Pair(ctx, \"tcp://localhost:5011\")),\n\t\t\t\tnew JavaOutliner(new Pair(ctx, \"tcp://localhost:5012\")),\n\t\t\t\tnew JavaCodeCompletion(new Pair(ctx, \"tcp://localhost:5013\"))\n\t\t\t\t);\n\t\tservers.forEach(server -> server.fork());\n\t}\n\tpublic void stop(BundleContext bundle) throws Exception {\n\t\tsource.close();\n\t\tsink.stop();\n\t\tservers.forEach(server -> server.stop());\n\t\tprofiler.close();\n\t\tplugin = null;\n\t\tsuper.stop(bundle);\n\t}\n\tpublic static Activator getDefault() {\n\t\treturn plugin;\n\t}\n\tpublic static Profiler getProfiler() {\n\t\treturn getDefault().profiler;\n\t}\n\tpublic static void debug(String msg, Object ... formatArgs) {\n\t\tgetDefault().getLog().log(new Status(Status.INFO, PLUGIN_ID, String.format(msg,formatArgs)));\n\t}\n\tpublic static void error(Exception e) {\n\t\terror(null, e);\n\t}\n\tpublic static void error(String msg, Exception e) {\n\t\tgetDefault().getLog().log(new Status(Status.ERROR, PLUGIN_ID, msg, e));\n\t}\n\tpublic static void addMessageListener(MessageListener listener) {\n\t\tgetDefault().messageListeners.add(listener);\n\t}\n\tpublic static void removeMessageListener(MessageListener listener) {\n\t\tgetDefault().messageListeners.remove(listener);\n\t}\n\tpublic static void sendMessage(VersionMessage version) {\n\t\tgetDefault().source.sendMessage(version);\n\t}\n\n}\nprivate class Activator10 extends AbstractUIPlugin {\n\tpublic static final String PLUGIN_ID = \"monto\"; //$NON-NLS-1$\n\tprivate static Activator plugin;\n\tprivate Profiler profiler;\n\tprivate List<Server> servers;\n\tprivate Set<MessageListener> messageListeners = new HashSet<>();\n\tprivate ProductRegistry products = new ProductRegistry();\n\tprivate PublishSource source;\n\tprivate Sink sink;\n\tpublic void start(BundleContext bundle) throws Exception {\n\t\tsuper.start(bundle);\n\t\tplugin = this;\n\t\tString profFile = LocalDateTime.now().format(DateTimeFormatter.ofPattern(\"yyyy-MM-dd-kk-mm-ss\"))+\".csv\";\n\t\tprofiler = new Profiler(new PrintWriter(new BufferedWriter(new FileWriter(profFile))));\n\t\tContext ctx = ZMQ.context(1);\n\t\tsource = new PublishSource(new Publish(ctx, \"tcp://localhost:5000\"));\n\t\tsource.connect();\n\t\tsink = new Sink(new Subscribe(ctx, \"tcp://localhost:5001\")) {\n\t\t\t@Override public void onMessage(ProductMessage msg) {\n\t\t\t\tfor(MessageListener listener : messageListeners)\n\t\t\t\t\tlistener.onMessage(msg);\n\t\t\t\tproducts.registerProduct(msg.getSource(),msg.getProduct(),msg.getLanguage());\n\t\t\t}\n\t\t};\n\t\tsink.fork();\n\t\tservers = Arrays.asList(\n\t\t\t\tnew JavaTokenizer(new Pair(ctx, \"tcp://localhost:5010\")),\n\t\t\t\tnew JavaParser(new Pair(ctx, \"tcp://localhost:5011\")),\n\t\t\t\tnew JavaOutliner(new Pair(ctx, \"tcp://localhost:5012\")),\n\t\t\t\tnew JavaCodeCompletion(new Pair(ctx, \"tcp://localhost:5013\"))\n\t\t\t\t);\n\t\tservers.forEach(server -> server.fork());\n\t}\n\tpublic void stop(BundleContext bundle) throws Exception {\n\t\tsource.close();\n\t\tsink.stop();\n\t\tservers.forEach(server -> server.stop());\n\t\tprofiler.close();\n\t\tplugin = null;\n\t\tsuper.stop(bundle);\n\t}\n\tpublic static Activator getDefault() {\n\t\treturn plugin;\n\t}\n\tpublic static Profiler getProfiler() {\n\t\treturn getDefault().profiler;\n\t}\n\tpublic static void debug(String msg, Object ... formatArgs) {\n\t\tgetDefault().getLog().log(new Status(Status.INFO, PLUGIN_ID, String.format(msg,formatArgs)));\n\t}\n\tpublic static void error(Exception e) {\n\t\terror(null, e);\n\t}\n\tpublic static void error(String msg, Exception e) {\n\t\tgetDefault().getLog().log(new Status(Status.ERROR, PLUGIN_ID, msg, e));\n\t}\n\tpublic static void addMessageListener(MessageListener listener) {\n\t\tgetDefault().messageListeners.add(listener);\n\t}\n\tpublic static void removeMessageListener(MessageListener listener) {\n\t\tgetDefault().messageListeners.remove(listener);\n\t}\n\tpublic static void sendMessage(VersionMessage version) {\n\t\tgetDefault().source.sendMessage(version);\n\t}\n\n}\nprivate class Activator extends AbstractUIPlugin {\n\tpublic static final String PLUGIN_ID = \"monto\"; //$NON-NLS-1$\n\tprivate static Activator plugin;\n\tprivate Profiler profiler;\n\tprivate List<Server> servers;\n\tprivate Set<MessageListener> messageListeners = new HashSet<>();\n\tprivate ProductRegistry products = new ProductRegistry();\n\tprivate PublishSource source;\n\tprivate Sink sink;\n\tpublic void start(BundleContext bundle) throws Exception {\n\t\tsuper.start(bundle);\n\t\tplugin = this;\n\t\tString profFile = LocalDateTime.now().format(DateTimeFormatter.ofPattern(\"yyyy-MM-dd-kk-mm-ss\"))+\".csv\";\n\t\tprofiler = new Profiler(new PrintWriter(new BufferedWriter(new FileWriter(profFile))));\n\t\tContext ctx = ZMQ.context(1);\n\t\tsource = new PublishSource(new Publish(ctx, \"tcp://localhost:5000\"));\n\t\tsource.connect();\n\t\tsink = new Sink(new Subscribe(ctx, \"tcp://localhost:5001\")) {\n\t\t\t@Override public void onMessage(ProductMessage msg) {\n\t\t\t\tfor(MessageListener listener : messageListeners)\n\t\t\t\t\tlistener.onMessage(msg);\n\t\t\t\tproducts.registerProduct(msg.getSource(),msg.getProduct(),msg.getLanguage());\n\t\t\t}\n\t\t};\n\t\tsink.fork();\n\t\tservers = Arrays.asList(\n\t\t\t\tnew JavaTokenizer(new Pair(ctx, \"tcp://localhost:5010\")),\n\t\t\t\tnew JavaParser(new Pair(ctx, \"tcp://localhost:5011\")),\n\t\t\t\tnew JavaOutliner(new Pair(ctx, \"tcp://localhost:5012\")),\n\t\t\t\tnew JavaCodeCompletion(new Pair(ctx, \"tcp://localhost:5013\"))\n\t\t\t\t);\n\t\tservers.forEach(server -> server.fork());\n\t}\n}\n}\n";
	
	public static final VersionMessage TESTMESSAGE_LINES10 = new VersionMessage(new LongKey(0L), new Source("java-10lines.java"), Languages.JAVA, LINES10, new ArrayList<Selection>(Arrays.asList(new Selection(2, 1))));
	public static final VersionMessage TESTMESSAGE_LINES100 = new VersionMessage(new LongKey(0L), new Source("java-100lines.java"), Languages.JAVA, LINES100, new ArrayList<Selection>(Arrays.asList(new Selection(3110, 0))));
	public static final VersionMessage TESTMESSAGE_LINES1000 = new VersionMessage(new LongKey(0L), new Source("java-1000lines.java"), Languages.JAVA, LINES1000, new ArrayList<Selection>(Arrays.asList(new Selection(7216, 0))));
}
